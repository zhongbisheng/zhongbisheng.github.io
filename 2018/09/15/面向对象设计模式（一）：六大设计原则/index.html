<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Wendell&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      面向对象设计模式（一）：六大设计原则 | Wendell&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://oindk07nf.qnssl.com/atom-one-dark.css" media="screen" type="text/css">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Wendell's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>面向对象设计模式（一）：六大设计原则</h2>
  <p class="post-date">2018-09-15</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>原文链接：<a href="https://juejin.im/post/5b9526c1e51d450e69731dc2" target="_blank" rel="noopener">https://juejin.im/post/5b9526c1e51d450e69731dc2</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习设计模式之前，学习面向对象设计（OOD：Object Oriented Design）的设计原则是很有必要的，为后面设计模式的学习打下基础。</p>
<p>本篇分享的就是笔者近阶段学习和总结的面向对象设计的六大设计原则：</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRP</td>
<td>Single Responsibility Principle</td>
<td>单一职责原则</td>
</tr>
<tr>
<td>OCP</td>
<td>Open Close Principle</td>
<td>开闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>Liskov Substitution Principle</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>LoD</td>
<td>Law of Demeter （ Least Knowledge Principle）</td>
<td>迪米特法则（最少知道原则）</td>
</tr>
<tr>
<td>ISP</td>
<td>Interface Segregation Principle</td>
<td>接口分离原则</td>
</tr>
<tr>
<td>DIP</td>
<td>Dependency Inversion Principle</td>
<td>依赖倒置原则</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：通常所说的 <strong>SOLID</strong>（上方表格缩写的首字母，从上到下）设计原则没有包含本篇介绍的迪米特法则，而只有其他五项。另外，本篇不包含<strong>合成/聚合复用原则（CARP）</strong>，因为笔者认为该原则没有其他六个原则典型，而且在实践中也不容易违背。有兴趣的同学可以自行查资料学习。</p>
</blockquote>
<p>在下一章笔者将分别讲解这些设计原则，讲解的方式是将概念与代码及其对应的 UML 类图结合起来讲解。</p>
<p>代码使用的是笔者最熟悉的 Objective-C 语言。虽然是一个比较小众的语言，但是因为有 UML 类图的帮助，而且主流的面向对象语言关于类，接口（Objective-C 里面是协议）的使用在形式上类似，所以笔者相信语言的小众不会对知识的理解产生太大的阻力。</p>
<p>另外，在每个设计模式的讲解里，笔者会首先描述一个应用场景（需求点），接着用两种设计的代码来进行对比讲解：先提供相对不好的设计的代码，再提供相对好的设计的代码。而且两种代码都会附上标准的 UML 类图来进行更形象地对比，帮助大家来理解。同时也可以帮助不了解 UML 类图的读者先简单熟悉一下 UML 类图的语法。</p>
<h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p>本篇讲解六大设计原则的顺序大致按照难易程度排列。在这里最先讲解开闭原则，因为其在理解上比较简单，而且也是其他设计原则的基石。</p>
<h2 id="原则一：开闭原则（Open-Close-Principle）"><a href="#原则一：开闭原则（Open-Close-Principle）" class="headerlink" title="原则一：开闭原则（Open Close Principle）"></a>原则一：开闭原则（Open Close Principle）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
</blockquote>
<h3 id="定义的解读"><a href="#定义的解读" class="headerlink" title="定义的解读"></a>定义的解读</h3><ul>
<li>用抽象构建框架，用实现扩展细节；</li>
<li>不以改动原有类的方式来实现新需求，而是应该以实现事先抽象出来的接口（或具体类继承抽象类）的方式来实现。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实现开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本。</p>
<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个简单的关于在线课程的例子讲解一下开闭原则的实践。</p>
<h4 id="需求点"><a href="#需求点" class="headerlink" title="需求点"></a>需求点</h4><p>设计一个在线课程类：</p>
<p>由于教学资源有限，开始的时候只有类似于博客的，通过文字讲解的课程。但是随着教学资源的增多，后来增加了视频课程，音频课程以及直播课程。</p>
<p>先来看一下不好的设计：</p>
<h4 id="不好的设计"><a href="#不好的设计" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>最开始的文字课程类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// .h</span><br><span class="line">@interface Course : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *courseTitle;         // 课程名称</span><br><span class="line">@property (nonatomic, copy) NSString *courseIntroduction;  // 课程介绍</span><br><span class="line">@property (nonatomic, copy) NSString *teacherName;         // 讲师姓名</span><br><span class="line">@property (nonatomic, copy) NSString *content;             // 课程内容</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>Course</strong> 类声明了最初的在线课程所需要包含的数据：</p>
<ul>
<li>课程名称</li>
<li>课程介绍</li>
<li>讲师姓名</li>
<li>文字内容</li>
</ul>
<p>接着按照上面所说的需求变更：增加了视频、音频、直播课程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// .h</span><br><span class="line">@interface Course : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *courseTitle;         // 课程名称</span><br><span class="line">@property (nonatomic, copy) NSString *courseIntroduction;  // 课程介绍</span><br><span class="line">@property (nonatomic, copy) NSString *teacherName;         // 讲师姓名</span><br><span class="line">@property (nonatomic, copy) NSString *content;             // 文字内容</span><br><span class="line"></span><br><span class="line">// 新需求：视频课程</span><br><span class="line">@property (nonatomic, copy) NSString *videoUrl;</span><br><span class="line"></span><br><span class="line">// 新需求：音频课程</span><br><span class="line">@property (nonatomic, copy) NSString *audioUrl;</span><br><span class="line"></span><br><span class="line">// 新需求：直播课程</span><br><span class="line">@property (nonatomic, copy) NSString *liveUrl;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>三种新增的课程都在原 <strong>Course</strong> 类中添加了对应的 URL。也就是每次添加一个新的类型的课程，都在原有 <strong>Course</strong> 类里面修改：新增这种课程需要的数据。</p>
<p>这就导致：我们从 <strong>Course</strong> 类实例化的视频课程对象会包含并不属于自己的数据：<code>audioUrl</code> 和 <code>liveUrl</code>，这样就造成了冗余，视频课程对象并不是纯粹的视频课程对象，它包含了音频地址、直播地址等属性。</p>
<p>很显然，这个设计不是一个好的设计，因为（对应上面两段叙述）：</p>
<ol>
<li>随着需求的增加，需要反复修改之前创建的类；</li>
<li>给新增的类造成了不必要的冗余。</li>
</ol>
<p>之所以会造成上述两个缺陷，是因为该设计没有遵循对修改关闭，对扩展开放的开闭原则，而是反其道而行之：开放修改，而且不给扩展提供便利。</p>
<p>那么怎么做可以遵循开闭原则呢？下面看一下遵循开闭原则的较好的设计：</p>
<h4 id="较好的设计"><a href="#较好的设计" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>首先在 <strong>Course</strong> 类中仅仅保留所有课程都含有的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// .h</span><br><span class="line">@interface Course : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *courseTitle;         // 课程名称</span><br><span class="line">@property (nonatomic, copy) NSString *courseIntroduction;  // 课程介绍</span><br><span class="line">@property (nonatomic, copy) NSString *teacherName;         // 讲师姓名</span><br><span class="line">@property (nonatomic, copy) NSString *content;             // 课程内容</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接着，针对文字课程、视频课程、音频课程，直播课程这三种新型的课程采用继承 <strong>Course</strong> 类的方式。而且继承后，添加自己独有的数据：</p>
<p>文字课程类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface TextCourse : Course</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *content;             // 文字内容</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>视频课程类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface VideoCourse : Course</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *videoUrl;            // 视频地址</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>音频课程类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface AudioCourse : Course</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *audioUrl;            // 音频地址</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>直播课程类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface LiveCourse : Course</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *liveUrl;             // 直播地址</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样一来，上面的两个问题都得到了解决：</p>
<ol>
<li>随着课程类型的增加，不需要反复修改最初的父类 <strong>Course</strong>，只需要新建一个继承于它的子类并在子类中添加仅属于该子类的数据（或行为）即可；</li>
<li>因为各种课程独有的数据（或行为）都被分散到了不同的课程子类里，所以每个子类的数据（或行为）没有任何冗余。</li>
</ol>
<p>而且对于第二点：或许今后的视频课程可以有高清地址，视频加速功能。而这些功能只需要在 <strong>VideoCourse</strong> 类里添加即可，因为它们都是视频课程所独有的。同样地，直播课程后面还可以支持在线问答功能，也可以仅加在 <strong>LiveCourse</strong> 里面。</p>
<p>我们可以看到，正是由于最初程序设计合理，所以对后面需求的增加才会处理得很好。</p>
<p>下面来看一下这两个设计的 UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比"><a href="#UML-类图对比" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践开闭原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190214224619.jpg" alt=""></p>
<p>实践了开闭原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190214224651.jpg" alt=""></p>
<blockquote>
<p>在实践了开闭原则的 UML 类图中，四个课程类继承了 <strong>Course</strong> 类并增加了自己独有的属性。（在 UML 类图中，实践空心三角箭头代表继承关系，由子类指向其父类）</p>
</blockquote>
<h3 id="如何实践"><a href="#如何实践" class="headerlink" title="如何实践"></a>如何实践</h3><p>为了更好地实践开闭原则，在设计之初就要清楚在该场景里哪些数据（或行为）是一定不变（或很难再改变）的，哪些是很容易变动的。将后者抽象成接口或抽象方法，以便于在将来通过创造具体的实现应对不同的需求。</p>
<h2 id="原则二：单一职责原则（Single-Responsibility-Principle）"><a href="#原则二：单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="原则二：单一职责原则（Single Responsibility Principle）"></a>原则二：单一职责原则（Single Responsibility Principle）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>A class should have a single responsibility, where a responsibility is nothing but a reason to change.</p>
<p>一个类只允许有一个职责，即只有一个导致该类变更的原因。</p>
</blockquote>
<h3 id="定义的解读-1"><a href="#定义的解读-1" class="headerlink" title="定义的解读"></a>定义的解读</h3><ul>
<li>类职责的变化往往就是导致类变化的原因，也就是说如果一个类具有多种职责，就会有多种导致这个类变化的原因，从而导致这个类的维护变得困难；</li>
<li>往往在软件开发中随着需求的不断增加，可能会给原来的类添加一些本来不属于它的一些职责，从而违反了单一职责原则。如果我们发现当前类的职责不仅仅有一个，就应该将本来不属于该类真正的职责分离出去；</li>
<li>不仅仅是类，函数（方法）也要遵循单一职责原则，即：一个函数只做一件事情。如果发现一个函数里面有不同的任务，则需要将不同的任务以另一个函数的形式分离出去。</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>如果类与方法的职责划分得很清晰，不但可以提高代码的可读性，更实际性地降低了程序出错的风险，因为清晰的代码会让 bug 无处藏身，也有利于 bug 的追踪，也就降低了程序的维护成本。</p>
<h3 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>单一职责原则的 demo 比较简单，通过对象（属性）的设计上讲解已经足够，不需要具体的客户端调用。我们先看一下需求点：</p>
<h4 id="需求点-1"><a href="#需求点-1" class="headerlink" title="需求点"></a>需求点</h4><p>初始需求：需要创造一个员工类，这个类有员工的一些基本信息。</p>
<p>新增需求：增加两个方法</p>
<ul>
<li>判定员工在今年是否升职；</li>
<li>计算员工的薪水。</li>
</ul>
<p>先来看一下不好的设计：</p>
<h4 id="不好的设计-1"><a href="#不好的设计-1" class="headerlink" title="不好的设计"></a>不好的设计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//================== Employee.h ==================</span><br><span class="line">@interface Employee : NSObject</span><br><span class="line"></span><br><span class="line">//============ 初始需求 ============</span><br><span class="line">@property (nonatomic, copy) NSString *name;       // 员工姓名</span><br><span class="line">@property (nonatomic, copy) NSString *address;    // 员工住址</span><br><span class="line">@property (nonatomic, copy) NSString *employeeID; // 员工ID</span><br><span class="line"></span><br><span class="line">//============ 新需求 ============</span><br><span class="line">// 计算薪水</span><br><span class="line">- (double)calculateSalary;</span><br><span class="line"></span><br><span class="line">// 今年是否晋升</span><br><span class="line">- (BOOL)willGetPromotionThisYear;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出：</p>
<ul>
<li>在初始需求下，我们创建了 <strong>Employee</strong> 这个员工类，并声明了3个员工信息的属性：姓名、住址和员工ID；</li>
<li>在新需求下，两个方法直接加到了员工类里面。</li>
</ul>
<p>新需求的做法看似没有问题，因为都是和员工有关的，但却违反了单一职责原则：<strong>因为这两个方法并不是员工本身的职责</strong>：</p>
<ul>
<li><code>calculateSalary</code> 这个方法的职责是属于会计部门的，薪水的计算是会计部门负责；</li>
<li><code>willPromotionThisYear</code> 这个方法的职责是属于人事部门的，考核与晋升机制是人事部门负责。</li>
</ul>
<p>而上面的设计将本来不属于员工自己的职责加进了员工类里面，而这个类的设计初衷（原始职责）就是单纯地保留员工的一些信息而已。因此这么做就是给这个类引入了新的职责，故此设计违反了单一职责原则。</p>
<p>我们可以简单设想一下这么做的后果是什么：如果员工的晋升机制变了，或者税收政策等影响员工工资的因素变了，我们还需要修改当前这个类。</p>
<p>那么怎么做才能不违反单一职责原则呢？我们需要将这两个方法（责任）分离出去，让本应该处理这类任务的类来处理。</p>
<h4 id="较好的设计-1"><a href="#较好的设计-1" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>我们保留员工类的基本信息，接着创建新的<strong>会计部门类</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//================== FinancialApartment.h ==================</span><br><span class="line">#import &quot;Employee.h&quot;</span><br><span class="line"></span><br><span class="line">//会计部门类</span><br><span class="line">@interface FinancialApartment : NSObject</span><br><span class="line"></span><br><span class="line">//计算薪水</span><br><span class="line">- (double)calculateSalary:(Employee *)employee;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>和<strong>人事部门类</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//================== HRApartment.h ==================</span><br><span class="line">#import &quot;Employee.h&quot;</span><br><span class="line"></span><br><span class="line">//人事部门类</span><br><span class="line">@interface HRApartment : NSObject</span><br><span class="line"></span><br><span class="line">//今年是否晋升</span><br><span class="line">- (BOOL)willGetPromotionThisYear:(Employee*)employee;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>通过创建了两个分别处理薪水和晋升的部门：会计部门 <strong>FinancialApartment</strong> 和人事部门 <strong>HRApartment</strong>，把两个任务（责任）分离了出去，让本该处理这些职责的类来处理这些职责。</p>
<p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加人事部门和会计部门处理的任务，就可以直接在这两个类里面添加即可。</p>
<p>下面来看一下这两个设计的 UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比-1"><a href="#UML-类图对比-1" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践单一职责原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190215170951.jpg" alt=""></p>
<p>实践了单一职责原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190215171026.jpg" alt=""></p>
<blockquote>
<p>可以看到，在实践了单一职责原则的 UML 类图中，不属于 <strong>Employee</strong> 的两个职责被分离到 <strong>FinancialApartment</strong> 和 <strong>HRApartment</strong>。（在 UML 中，虚线箭头表示依赖关系，常用在方法参数等，由依赖方指向被依赖方）</p>
</blockquote>
<p>上面说过除了类要遵循单一职责设计原则之外，在函数（方法）的设计上也要遵循单一职责原则。因函数的单一职责原则理解起来比较容易，故在这里就不提供 demo 和 UML 类图了。</p>
<p>可以简单举一个例子：</p>
<p>APP的默认导航栏的样式是这样的：</p>
<ul>
<li>白色底</li>
<li>黑色标题</li>
<li>底部有阴影</li>
</ul>
<p>那么创建默认导航栏的伪代码可能是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认样式的导航栏</span><br><span class="line">- (void)createDefaultNavigationBarWithTitle:(NSString *)title &#123;</span><br><span class="line">    // create white color background view</span><br><span class="line">    </span><br><span class="line">    // create black color title</span><br><span class="line">    </span><br><span class="line">    // create shadow bottom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以用这个方法统一创建默认的导航了了。但是过不久又有新的需求来了，有的页面的导航栏需要做成透明的，因此需要一个透明样式的导航栏：</p>
<ul>
<li>透明底</li>
<li>白色标题</li>
<li>底部无阴影</li>
</ul>
<p>针对这个需求，我们可以新增一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 透明样式的导航栏</span><br><span class="line">- (void)createTransParentNavigationBarWithTitle:(NSString *)title &#123;</span><br><span class="line">    // create transparent color background view</span><br><span class="line">    </span><br><span class="line">    // create white color title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看出问题来了么？在这两个方法里面，创造 background view 和 title color title 的方法的差别仅仅是颜色不同而已，而其他部分的代码是重复的。因此我们应该将这两个方法抽出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 根据传入的颜色参数设置导航栏的背景色</span><br><span class="line">- (void)createBackgroundViewWithColor:(UIColor)color;</span><br><span class="line"></span><br><span class="line">// 根据传入的标题字符串和颜色参数设置标题</span><br><span class="line">- (void)createTitlewWithColorWithTitle:(NSString *)title color:(UIColor)color;</span><br></pre></td></tr></table></figure>
<p>而且上面的制造阴影的部分也可以作为方法抽出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)createShadowBottom;</span><br></pre></td></tr></table></figure>
<p>这样一来，原来的两个方法可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 默认样式的导航栏</span><br><span class="line">- (void)createDefaultNavigationBarWithTitle:(NSString *)title &#123;</span><br><span class="line">    // 设置白色背景</span><br><span class="line">    [self createBackgroundViewWithColor:[UIColor whiteColor]];</span><br><span class="line">    </span><br><span class="line">    // 设置黑色标题</span><br><span class="line">    [self createTitlewWithColorWithTitle:title color:[UIColor blackColor]];</span><br><span class="line">    </span><br><span class="line">    // 设置底部阴影</span><br><span class="line">    [self createShadowBottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 透明样式的导航栏</span><br><span class="line">- (void)createTransParentNavigationBarWithTitle:(NSString *)title &#123;</span><br><span class="line">    // 设置透明背景</span><br><span class="line">    [self createBackgroundViewWithColor:[UIColor clearColor]];</span><br><span class="line">    </span><br><span class="line">    // 设置白色标题</span><br><span class="line">    [self createTitlewWithColorWithTitle:title color:[UIColor whiteColor]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且我们也可以将里面的方法拿出来在外面调用也可以：</p>
<p>设置默认样式的导航栏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设置白色背景</span><br><span class="line">[navigationBar createBackgroundViewWithColor:[UIColor whiteColor]];</span><br><span class="line"></span><br><span class="line">// 设置黑色标题</span><br><span class="line">[navigationBar createTitlewWithColorWithTitle:title color:[UIColor blackColor]];</span><br><span class="line"></span><br><span class="line">// 设置阴影</span><br><span class="line">[navigationBar createShadowBottom];</span><br></pre></td></tr></table></figure>
<p>设置透明样式的导航栏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置透明色背景</span><br><span class="line">[navigationBar createBackgroundViewWithColor:[UIColor clearColor]];</span><br><span class="line"></span><br><span class="line">// 设置白色标题</span><br><span class="line">[navigationBar createTitlewWithColorWithTitle:title color:[UIColor whiteColor]];</span><br></pre></td></tr></table></figure>
<p>这样一来，无论写在一个大方法里面调用或是分别在外面调用，都能很清楚地看到导航栏的每个元素是如何生成的，因为每个职责都分配到了一个单独的方法里面。而且还有一个好处是，透明导航栏如果遇到浅色背景的话，使用白色字体不如使用黑色字体好，所以遇到这种情况我们可以在 <code>createTitlewWithColorWithTitle:color:</code> 方法里面传入黑色色值。而且今后可能还会有更多的导航栏样式，那么我们只需要分别改变传入的色值即可，不需要有大量的重复代码了，修改起来也很方便。</p>
<h3 id="如何实践-1"><a href="#如何实践-1" class="headerlink" title="如何实践"></a>如何实践</h3><p>对于上面的员工类的例子，或许是因为我们先入为主，知道一个公司的合理组织架构，觉得这么设计理所当然。但是在实际开发中，我们很容易会将不同的责任揉在一起，这点还是需要开发者注意的。</p>
<h2 id="原则三：依赖倒置原则（Dependency-Inversion-Principle）"><a href="#原则三：依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="原则三：依赖倒置原则（Dependency Inversion Principle）"></a>原则三：依赖倒置原则（Dependency Inversion Principle）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote>
<ul>
<li><p>Depend upon Abstractions. Do not depend upon concretions.</p>
<p>依赖抽象，而不是依赖实现</p>
</li>
<li><p>Abstractions should not depend upon details. Details should depend upon abstractions</p>
<p>抽象不应该依赖细节；细节应该依赖抽象</p>
</li>
<li><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
<p>高层模块不能依赖底层模块，二者都应该依赖抽象</p>
</li>
</ul>
</blockquote>
<h3 id="定义解读"><a href="#定义解读" class="headerlink" title="定义解读"></a>定义解读</h3><ul>
<li>针对接口编程，而不是针对实现编程；</li>
<li>尽量不要从具体的类派生，而是以继承抽象类或实现接口来实现；</li>
<li>关于高层模块与低层模块的划分可以按照决策能力的高低进行划分。业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层，</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</p>
<h3 id="代码讲解-2"><a href="#代码讲解-2" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个模拟项目开发的例子来讲解依赖倒置原则。</p>
<h4 id="需求点-2"><a href="#需求点-2" class="headerlink" title="需求点"></a>需求点</h4><p>实现下面这样的需求：</p>
<p>用代码模拟一个实际项目开发的场景：前端和后端开发人员开发同一个项目。</p>
<h4 id="不好的设计-2"><a href="#不好的设计-2" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>首先生成两个类，分别对应前端和后端开发者：</p>
<p>前端开发者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//================== FrondEndDeveloper.h ==================</span><br><span class="line">@interface FrondEndDeveloper : NSObject</span><br><span class="line"></span><br><span class="line">- (void)writeJavaScriptCode;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== FrondEndDeveloper.m ==================</span><br><span class="line">@implementation FrondEndDeveloper</span><br><span class="line"></span><br><span class="line">- (void)writeJavaScriptCode &#123;</span><br><span class="line">    NSLog(@&quot;Write JavaScript code&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>后端开发者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//================== BackEndDeveloper.h ==================</span><br><span class="line">@interface BackEndDeveloper : NSObject</span><br><span class="line"></span><br><span class="line">- (void)writeJavaCode;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== BackEndDeveloper.m ==================</span><br><span class="line">@implementation BackEndDeveloper</span><br><span class="line"></span><br><span class="line">- (void)writeJavaCode &#123;</span><br><span class="line">    NSLog(@&quot;Write Java code&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这两个开发者分别对外提供了自己开发的方法：<code>writeJavaScriptCode</code> 和 <code>writeJavaCode</code>。</p>
<p>接着创建一个 <strong>Project</strong> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//================== Project.h ==================</span><br><span class="line">@interface Project : NSObject</span><br><span class="line"></span><br><span class="line">//构造方法，传入开发者的数组</span><br><span class="line">- (instancetype)initWithDevelopers:(NSArray *)developers;</span><br><span class="line"></span><br><span class="line">//开始开发</span><br><span class="line">- (void)startDeveloping;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Project.m ==================</span><br><span class="line">#import &quot;Project.h&quot;</span><br><span class="line">#import &quot;FrondEndDeveloper.h&quot;</span><br><span class="line">#import &quot;BackEndDeveloper.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Project &#123;</span><br><span class="line">    NSArray *_developers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDevelopers:(NSArray *)developers &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _developers = developers;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startDeveloping &#123;</span><br><span class="line">    [_developers enumerateObjectsUsingBlock:^(id  _Nonnull developer, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">        if ([developer isKindOfClass:[FrondEndDeveloper class]]) &#123;</span><br><span class="line">            [developer writeJavaScriptCode];</span><br><span class="line">        &#125; else if ([developer isKindOfClass:[BackEndDeveloper class]]) &#123;</span><br><span class="line">            [developer writeJavaCode];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //no such developer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在 <strong>Project</strong> 类中，我们首先通过一个构造器方法，将开发者的数组传入 <strong>Project</strong> 的实例对象。然后在开始开发的方法 <code>startDeveloping</code> 里面，遍历数组并判断元素类型的方式让不同类型的开发者调用和自己对应的函数。</p>
<p>思考一下，这样的设计有什么问题？</p>
<h4 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h4><p>假如后台的开发语言改成了 GO 语言，那么上述代码需要改动两个地方：</p>
<ul>
<li><strong>BackEndDeveloper</strong> 类需要向外提供一个 <code>writeGolangCode</code> 方法；</li>
<li><strong>Project</strong> 类的 <code>startDeveloping</code> 方法里面需要将 <strong>BackEndDeveloper</strong> 类的 <code>writeJavaCode</code> 改成 <code>writeGolangCode</code>。</li>
</ul>
<h4 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h4><p>假如后期老板要求做移动端的 APP（需要 iOS 和安卓的开发者），那么上述代码仍然需要改动两个地方：</p>
<ul>
<li>还需要给 <strong>Project</strong> 类的构造器方法里面传入 <strong>IOSDeveloper</strong> 和 <strong>AndroidDeveloper</strong> 两个类，而且按照现有的设计，还要分别向外部提供 <code>writeSwiftCode</code> 和 <code>writeKotlinCode</code> 方法；</li>
<li><strong>Project</strong> 类的 <code>startDeveloping</code> 方法里面需要再多两个 else if 判断，专门判断 <strong>IOSDeveloper</strong> 和 <strong>AndroidDeveloper</strong> 这两个类。</li>
</ul>
<p>很显然，在这两种假设的场景下，<strong>高层模块（Project）都依赖了低层模块（BackEndDeveloper）的改动，因此上述设计不符合依赖倒置原则</strong>。</p>
<p>那么该如何设计才可以符合依赖倒置原则呢？</p>
<p>答案是：<strong>将开发者写代码的方法抽象出来，让 Project 类不再依赖所有低层的开发者类的具体实现，而是依赖抽象。而且从下至上，所有低层开发者类也都依赖这个抽象，通过实现这个抽象来做自己的任务</strong>。</p>
<p>这个抽象可以用接口，也可以用抽象类的方式来做，在这里笔者用接口的方式进行讲解：</p>
<h4 id="较好的设计-2"><a href="#较好的设计-2" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>首先，创建一个接口，接口里面有一个写代码的方法 <code>writeCode</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//================== DeveloperProtocol.h ==================</span><br><span class="line">@protocol DeveloperProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)writeCode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后让前端程序员和后端程序员类实现这个接口（遵循这个协议）并按照自己的方式实现。</p>
<p>前端程序员类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//================== FrondEndDeveloper.h ==================</span><br><span class="line">@interface FrondEndDeveloper : NSObject&lt;DeveloperProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== FrondEndDeveloper.m ==================</span><br><span class="line"></span><br><span class="line">@implementation FrondEndDeveloper</span><br><span class="line"></span><br><span class="line">- (void)writeCode &#123;</span><br><span class="line">    NSLog(@&quot;Write JavaScript code&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>后端程序员类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//================== BackEndDeveloper.h ==================</span><br><span class="line">@interface BackEndDeveloper : NSObject&lt;DeveloperProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== BackEndDeveloper.m ==================</span><br><span class="line">@implementation BackEndDeveloper</span><br><span class="line"></span><br><span class="line">- (void)writeCode &#123;</span><br><span class="line">    NSLog(@&quot;Write Java code&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>最后我们看一下新设计后的 <strong>Project</strong> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//================== Project.h ==================</span><br><span class="line">#import &quot;DeveloperProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Project : NSObject</span><br><span class="line"></span><br><span class="line">//只需传入遵循DeveloperProtocol的对象数组即可</span><br><span class="line">- (instancetype)initWithDevelopers:(NSArray &lt;id &lt;DeveloperProtocol&gt;&gt;*)developers;</span><br><span class="line"></span><br><span class="line">//开始开发</span><br><span class="line">- (void)startDeveloping;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//================== Project.m ==================</span><br><span class="line">#import &quot;FrondEndDeveloper.h&quot;</span><br><span class="line">#import &quot;BackEndDeveloper.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Project &#123;</span><br><span class="line">    NSArray &lt;id &lt;DeveloperProtocol&gt;&gt;* _developers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDevelopers:(NSArray &lt;id &lt;DeveloperProtocol&gt;&gt;*)developers &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _developers = developers;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startDeveloping &#123;</span><br><span class="line">    //每次循环，直接向对象发送writeCode方法即可，不需要判断</span><br><span class="line">    [_developers enumerateObjectsUsingBlock:^(id&lt;DeveloperProtocol&gt;  _Nonnull developer, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [developer writeCode];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>新的 <strong>Project</strong> 的构造方法只需传入遵循 <strong><em>DeveloperProtocol</em></strong> 协议的对象构成的数组即可。这样也比较符合现实中的需求：只需要会写代码就可以加入到项目中。</p>
<p>而新的 <code>startDeveloping</code> 方法里，每次循环，直接向当前对象发送 <code>writeCode</code> 方法即可，不需要对程序员的类型做判断。因为这个对象一定是遵循 <strong><em>DeveloperProtocol</em></strong> 接口的，而遵循该接口的对象一定会实现 <code>writeCode</code> 方法（就算不实现也不会引起重大错误）。</p>
<p>现在新的设计接受完了，我们通过上面假设的两个情况来和之前的设计做个对比：</p>
<h4 id="假设1：后台的开发语言改成了-GO-语言"><a href="#假设1：后台的开发语言改成了-GO-语言" class="headerlink" title="假设1：后台的开发语言改成了 GO 语言"></a>假设1：后台的开发语言改成了 GO 语言</h4><p>在这种情况下，只需更改 <strong>BackEndDeveloper</strong> 类里面对于 <strong><em>DeveloperProtocol</em></strong>  接口的 <code>writeCode</code> 方法的实现即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//================== BackEndDeveloper.m ==================</span><br><span class="line">@implementation BackEndDeveloper</span><br><span class="line"></span><br><span class="line">- (void)writeCode &#123;</span><br><span class="line">    //Old：</span><br><span class="line">    //NSLog(@&quot;Write Java code&quot;);</span><br><span class="line">    </span><br><span class="line">    //New:</span><br><span class="line">    NSLog(@&quot;Write Golang code&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>而在 <strong>Project</strong> 里面不需要修改任何代码，因为 <strong>Project</strong> 类只依赖了接口方法 <code>writeCode</code>，没有依赖其具体的实现。</p>
<p>我们接着看一下第二个假设：</p>
<h4 id="假设2：后期老板要求做移动端的-APP（需要iOS和安卓的开发者）"><a href="#假设2：后期老板要求做移动端的-APP（需要iOS和安卓的开发者）" class="headerlink" title="假设2：后期老板要求做移动端的 APP（需要iOS和安卓的开发者）"></a>假设2：后期老板要求做移动端的 APP（需要iOS和安卓的开发者）</h4><p>在这个新场景下，我们只需要将新创建的两个开发者类：<strong>IOSDeveloper</strong> 和 <strong>AndroidDeveloper</strong> 分别实现<strong><em>DeveloperProtocol</em></strong> 接口的 <code>writeCode</code> 方法即可。</p>
<p>同样，<strong>Project</strong> 的接口和实现代码都不用修改：客户端只需要在 <strong>Project</strong> 的构建方法的数组参数里面添加这两个新类的实例即可，不需要在 <code>startDeveloping</code> 方法里面添加类型判断，原因同上。</p>
<p>我们可以看到，新设计很好地在高层类（<strong>Project</strong>）与低层类（各种 <strong>developer</strong> 类）中间加了一层抽象，解除了二者在旧设计中的耦合，使得在低层类中的改动没有影响到高层类。</p>
<p>同样是抽象，新设计同样也可以用抽象类的方式：创建一个 <strong>Developer</strong> 的抽象类并提供一个 <code>writeCode</code> 方法，让不同的开发者类继承于它并按照自己的方式实现 <code>writeCode</code> 方法。这样一来，在 <strong>Project</strong> 类的构造方法就是传入以 <strong>Developer</strong> 类型为元素的数组了。有兴趣的小伙伴可以自己实现一下。</p>
<p>下面来看一下这两个设计的 UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比-2"><a href="#UML-类图对比-2" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践依赖倒置原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190215212759.jpg" alt=""></p>
<p>实践了依赖倒置原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190215212829.jpg" alt=""></p>
<blockquote>
<p>在实践了依赖倒置原则的 UML 类图中，我们可以看到 <strong>Project</strong> 仅仅依赖于新的接口，而且低层的<strong>FrondEndDevelope</strong> 和 <strong>BackEndDevelope</strong> 类按照自己的方式实现了这个接口，通过接口解除了原有的依赖。（在 UML 类图中，虚线三角箭头表示接口实线，由实现方指向接口）</p>
</blockquote>
<h3 id="如何实践-2"><a href="#如何实践-2" class="headerlink" title="如何实践"></a>如何实践</h3><p>今后在处理高低层模块（类）交互的情景时，尽量将二者的依赖通过抽象的方式解除掉，实现方式可以是通过接口也可以是抽象类的方式。</p>
<h2 id="原则四：接口分离原则（Interface-Segregation-Principle）"><a href="#原则四：接口分离原则（Interface-Segregation-Principle）" class="headerlink" title="原则四：接口分离原则（Interface Segregation Principle）"></a>原则四：接口分离原则（Interface Segregation Principle）</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Many client specific interfaces are better than one general purpose interface.</p>
<p>多个特定的客户端接口要好于一个通用性的总接口。</p>
</blockquote>
<h3 id="定义解读-1"><a href="#定义解读-1" class="headerlink" title="定义解读"></a>定义解读</h3><ul>
<li>客户端不应该依赖它不需要实现的接口；</li>
<li>不建立庞大臃肿的接口，应尽量细化接口，接口中的方法应该尽量少。</li>
</ul>
<p>需要注意的是：接口的粒度也不能太小。如果太小，则会造成接口数量过多，使设计复杂化。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。</p>
<h3 id="代码讲解-3"><a href="#代码讲解-3" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个餐厅服务的例子讲解一下接口分离原则。</p>
<h4 id="需求点-3"><a href="#需求点-3" class="headerlink" title="需求点"></a>需求点</h4><p>现在的餐厅除了提供传统的店内服务，多数也都支持网上下单，网上支付功能。写一些接口方法来涵盖餐厅的所有的下单及支付功能。</p>
<h4 id="不好的设计-3"><a href="#不好的设计-3" class="headerlink" title="不好的设计"></a>不好的设计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//================== RestaurantProtocol.h ==================</span><br><span class="line">@protocol RestaurantProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)placeOnlineOrder;         // 下订单：online</span><br><span class="line">- (void)placeTelephoneOrder;      // 下订单：通过电话</span><br><span class="line">- (void)placeWalkInCustomerOrder; // 下订单：在店里</span><br><span class="line"></span><br><span class="line">- (void)payOnline;                // 支付订单：online</span><br><span class="line">- (void)payInPerson;              // 支付订单：在店里支付</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在这里声明了一个接口，它包含了下单和支付的几种方式：</p>
<ul>
<li>下单：<ul>
<li>online 下单</li>
<li>电话下单</li>
<li>店里下单（店内服务）</li>
</ul>
</li>
<li>支付<ul>
<li>online 支付（适用于 online 下单和电话下单的顾客）</li>
<li>店里支付（店内服务）</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里先不讨论电话下单的顾客是用 online 支付还是店内支付。</p>
</blockquote>
<p>对应的，我们有三种下单方式的顾客：</p>
<ol>
<li><p>online 下单，online 支付的顾客；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//================== OnlineClient.h ==================</span><br><span class="line">#import &quot;RestaurantProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">@interface OnlineClient : NSObject&lt;RestaurantProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== OnlineClient.m ==================</span><br><span class="line">@implementation OnlineClient</span><br><span class="line"></span><br><span class="line">- (void)placeOnlineOrder &#123;</span><br><span class="line">    NSLog(@&quot;place on line order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeTelephoneOrder &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeWalkInCustomerOrder &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOnline &#123;</span><br><span class="line">    NSLog(@&quot;pay on line&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payInPerson &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>电话下单，online 支付的顾客；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//================== TelephoneClient.h ==================</span><br><span class="line">#import &quot;RestaurantProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TelephoneClient : NSObject&lt;RestaurantProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== TelephoneClient.m ==================</span><br><span class="line">@implementation TelephoneClient</span><br><span class="line"></span><br><span class="line">- (void)placeOnlineOrder &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeTelephoneOrder &#123;</span><br><span class="line">    NSLog(@&quot;place telephone order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeWalkInCustomerOrder &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOnline &#123;</span><br><span class="line">    NSLog(@&quot;pay on line&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payInPerson &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在店里下单并支付的顾客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//================== WalkinClient.h ==================</span><br><span class="line">#import &quot;RestaurantProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">@interface WalkinClient : NSObject&lt;RestaurantProtocol&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== WalkinClient.m ==================</span><br><span class="line">@implementation WalkinClient</span><br><span class="line"></span><br><span class="line">- (void)placeOnlineOrder &#123;</span><br><span class="line">   // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeTelephoneOrder &#123;</span><br><span class="line">    // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeWalkInCustomerOrder &#123;</span><br><span class="line">    NSLog(@&quot;place walk in customer order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOnline &#123;</span><br><span class="line">   // not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payInPerson &#123;</span><br><span class="line">    NSLog(@&quot;pay in person&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们发现，并不是所有顾客都必须要实现 <strong><em>RestaurantProtocol</em></strong> 里面的所有方法。<strong>由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</strong></p>
<blockquote>
<p>注意，Objective-C 中的协议可以通过 <strong>@optional</strong> 关键字设置不需要必须实现的方法，该特性不与接口分离原则冲突，只要属于同一类责任的接口，都可以放入同一接口中。</p>
</blockquote>
<p>那么如何做才符合接口隔离原则呢？我们来看一下较好的设计。</p>
<h4 id="较好的设计-3"><a href="#较好的设计-3" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>要符合接口隔离原则，只需要将不同类型的接口分离出来即可。我们将原来的 <strong><em>RestaurantProtocol</em></strong> 接口拆分成两个接口：下单接口和支付接口。</p>
<p>下单接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//================== RestaurantPlaceOrderProtocol.h ==================</span><br><span class="line">@protocol RestaurantPlaceOrderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)placeOrder;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>支付接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//================== RestaurantPaymentProtocol.h ==================</span><br><span class="line">@protocol RestaurantPaymentProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)payOrder;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>现在有了下单接口和支付接口，我们就可以让不同的客户来以自己的方式实现下单和支付操作了。</p>
<p>首先创建一个所有客户的父类，来遵循这两个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//================== Client.h ==================</span><br><span class="line">#import &quot;RestaurantPlaceOrderProtocol.h&quot;</span><br><span class="line">#import &quot;RestaurantPaymentProtocol.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Client : NSObject&lt;RestaurantPlaceOrderProtocol,RestaurantPaymentProtocol&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接着令 online下单、电话下单、店内下单的顾客继承这个父类，分别实现这两个接口的方法：</p>
<ol>
<li><p>online 下单，online 支付的顾客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//================== OnlineClient.h ==================</span><br><span class="line">#import &quot;Client.h&quot;</span><br><span class="line">@interface OnlineClient : Client</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== OnlineClient.m ==================</span><br><span class="line">@implementation OnlineClient</span><br><span class="line"></span><br><span class="line">- (void)placeOrder &#123;</span><br><span class="line">    NSLog(@&quot;place on line order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOrder &#123;</span><br><span class="line">    NSLog(@&quot;pay on line&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>电话下单，online 支付的顾客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//================== TelephoneClient.h ==================</span><br><span class="line">#import &quot;Client.h&quot;</span><br><span class="line">@interface TelephoneClient : Client</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== TelephoneClient.m ==================</span><br><span class="line">@implementation TelephoneClient</span><br><span class="line">    </span><br><span class="line">- (void)placeOrder &#123;</span><br><span class="line">    NSLog(@&quot;place telephone order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOrder &#123;</span><br><span class="line">    NSLog(@&quot;pay on line&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在店里下单并支付的顾客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//================== WalkinClient.h ==================</span><br><span class="line">#import &quot;Client.h&quot;</span><br><span class="line">@interface WalkinClient : Client</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== WalkinClient.m ==================</span><br><span class="line">@implementation WalkinClient</span><br><span class="line"></span><br><span class="line">- (void)placeOrder &#123;</span><br><span class="line">    NSLog(@&quot;place walk in customer order&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)payOrder &#123;</span><br><span class="line">    NSLog(@&quot;pay in person&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为我们把不同的职责的接口拆开，使得接口的责任更加清晰，简洁明了。不同的客户端可以根据自己的需求遵循所需要的接口来以自己的方式实现。</p>
<p>而且今后如果还有和下单或者支付相关的方法，也可以分别加入到各自的接口中，避免了接口的臃肿，同时也提高了程序的内聚性。</p>
<p>下面来看一下这两个设计的 UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比-3"><a href="#UML-类图对比-3" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践接口分离原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190216212835.jpg" alt=""></p>
<p>实践了接口分离原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190216212910.jpg" alt=""></p>
<blockquote>
<p>通过遵守接口分离原则，接口的设计变得更加简洁，而且各种客户类不需要实现自己不需要实现的接口。</p>
</blockquote>
<h3 id="如何实践-3"><a href="#如何实践-3" class="headerlink" title="如何实践"></a>如何实践</h3><p>在设计接口时，尤其是在向现有的接口添加方法时，我们需要仔细斟酌这些方法是否是处理同一类任务的：如果是则可以放在一起；如果不是则需要做拆分。</p>
<p>做 iOS 开发的朋友对 <strong>UITableView</strong> 的 <strong><em>UITableViewDelegate</em></strong> 和 <strong><em>UITableViewDataSource</em></strong> 这两个协议应该会非常熟悉。这两个协议里的方法都是与 <strong>UITableView</strong> 相关的，但 iOS SDK 的设计者却把这些方法放在不同的两个协议中。原因就是这两个协议所包含的方法所处理的任务是不同的两种：</p>
<ul>
<li><strong><em>UITableViewDelegate</em></strong>：含有的方法是 <strong>UITableView</strong> 的实例告知其代理一些点击事件的方法，即<strong>事件的传递</strong>，方向是从 <strong>UITableView</strong> 的实例到其代理；</li>
<li><strong><em>UITableViewDataSource</em></strong>：含有的方法是 <strong>UITableView</strong> 的代理传给 <strong>UITableView</strong> 一些必要数据供<strong>UITableView</strong> 展示出来，即<strong>数据的传递</strong>，方向是从 <strong>UITableView</strong> 的代理到 <strong>UITableView</strong>。</li>
</ul>
<p>很显然，<strong>UITableView</strong> 协议的设计者很好地实践了接口分离的原则，值得我们大家学习。</p>
<h2 id="原则五：迪米特法则（Law-of-Demeter）"><a href="#原则五：迪米特法则（Law-of-Demeter）" class="headerlink" title="原则五：迪米特法则（Law of Demeter）"></a>原则五：迪米特法则（Law of Demeter）</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>You only ask for objects which you directly need.</p>
<p>一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。</p>
</blockquote>
<h3 id="定义解读-2"><a href="#定义解读-2" class="headerlink" title="定义解读"></a>定义解读</h3><p>迪米特法则也叫做最少知道原则（Least Know Principle），一个类应该只和它的成员变量、方法的输入、返回参数中的类作交流，而不应该引入其他的类（间接交流）。</p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>实践迪米特法则可以良好地降低类与类之间的耦合，减少类与类之间的关联程度，让类与类之间的协作更加直接。</p>
<h3 id="代码讲解-4"><a href="#代码讲解-4" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个简单的关于汽车的例子来讲解一下迪米特法则。</p>
<h4 id="需求点-4"><a href="#需求点-4" class="headerlink" title="需求点"></a>需求点</h4><p>设计一个汽车类，包含汽车的品牌名称，引擎等成员变量。提供一个方法返回引擎的品牌名称。</p>
<h4 id="不好的设计-4"><a href="#不好的设计-4" class="headerlink" title="不好的设计"></a>不好的设计</h4><p><strong>Car</strong> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//================== Car.h ==================</span><br><span class="line">@class GasEngine;</span><br><span class="line">@interface Car : NSObject</span><br><span class="line"></span><br><span class="line">//构造方法</span><br><span class="line">- (instancetype)initWithEngine:(GasEngine *)engine;</span><br><span class="line"></span><br><span class="line">//返回私有成员变量：引擎的实例</span><br><span class="line">- (GasEngine *)usingEngine;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Car.m ==================</span><br><span class="line">#import &quot;Car.h&quot;</span><br><span class="line">#import &quot;GasEngine.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Car &#123;</span><br><span class="line">    GasEngine *_engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithEngine:(GasEngine *)engine &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (GasEngine *)usingEngine &#123;</span><br><span class="line">    return _engine;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，<strong>Car</strong> 的构造方法需要传入一个引擎的实例对象。而且因为引擎的实例对象被赋到了 <strong>Car</strong> 对象的私有成员变量里面。所以 <strong>Car</strong> 类给外部提供了一个返回引擎对象的方法：<code>usingEngine</code>。</p>
<p>而这个引擎类 <strong>GasEngine</strong> 有一个品牌名称的成员变量 <code>brandName</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//================== GasEngine.h ==================</span><br><span class="line">@interface GasEngine : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *brandName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样一来，客户端就可以拿到引擎的品牌名称了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//================== Client.m ==================</span><br><span class="line">#import &quot;GasEngine.h&quot;</span><br><span class="line">#import &quot;Car.h&quot;</span><br><span class="line"></span><br><span class="line">- (NSString *)findCarEngineBrandName:(Car *)car &#123;</span><br><span class="line">    GasEngine *engine = [car usingEngine];</span><br><span class="line">    NSString *engineBrandName = engine.brandName;//获取到了引擎的品牌名称</span><br><span class="line">    return engineBrandName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的设计完成了需求，但是却违反了迪米特法则。原因是<strong>在客户端的 <code>findCarEngineBrandName:</code> 中引入了和入参（Car）和返回值（NSString）无关的 GasEngine 对象，增加了客户端与 GasEngine 的耦合，而这个耦合显然是不必要更是可以避免的</strong>。</p>
<p>接下来我们看一下如何设计可以避免这样耦合：</p>
<h4 id="较好的设计-4"><a href="#较好的设计-4" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>同样是 <strong>Car</strong> 这个类，我们去掉原有的返回引擎对象的方法，而是增加一个直接返回引擎品牌名称的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)usingEngineBrandName &#123;</span><br><span class="line">    return _engine.brand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>usingEngineBrandName</code> 方法直接返回了引擎的品牌名称，所以在客户端里面就可以直接拿到这个值，而不需要间接地通过原来的 <strong>GasEngine</strong> 实例来获取。</p>
<p>我们来看一下客户端操作的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//================== Client.m ==================</span><br><span class="line">#import &quot;Car.h&quot;</span><br><span class="line"></span><br><span class="line">- (NSString *)findCarEngineBrandName:(Car *)car &#123;</span><br><span class="line">    NSString *engineBrandName = [car usingEngineBrandName]; //直接获取到了引擎的品牌名称</span><br><span class="line">    return engineBrandName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前的设计不同，在客户端里面，没有引入 <strong>GasEngine</strong> 类，而是直接通过 <strong>Car</strong> 实例获取到了需要的数据。</p>
<p>这样设计的好处是，如果这辆车的引擎换成了电动引擎(原来的 <strong>GasEngine</strong> 类换成了 <strong>ElectricEngine</strong> 类)，<strong>客户端代码可以不做任何修改</strong>！因为它没有引入任何引擎类，而是直接获取了引擎的品牌名称。</p>
<p>所以在这种情况下我们只需要修改 <strong>Car</strong> 类的 <code>usingEngineBrandName</code> 方法实现，将新引擎的品牌名称返回即可。</p>
<p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比-4"><a href="#UML-类图对比-4" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践迪米特法则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190216224054.jpg" alt=""></p>
<p>实践了迪米特法则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190216224111.jpg" alt=""></p>
<blockquote>
<p>很明显，在实践了迪米特法则的 UML 类图里面，没有了 <strong>Client</strong> 对 <strong>GasEngine</strong> 的依赖，耦合性降低。</p>
</blockquote>
<h3 id="如何实践-4"><a href="#如何实践-4" class="headerlink" title="如何实践"></a>如何实践</h3><p>今后在做对象与对象之间交互的设计时，应该极力避免引出中间对象的情况（需要导入其他对象的类）：需要什么对象直接返回即可，降低类之间的耦合度。</p>
<h2 id="原则六：里氏替换原则（Liskov-Substitution-Principle）"><a href="#原则六：里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="原则六：里氏替换原则（Liskov Substitution Principle）"></a>原则六：里氏替换原则（Liskov Substitution Principle）</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>In a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of the program (correctness, task performed, etc.)</p>
<p>所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。</p>
</blockquote>
<h3 id="定义解读-3"><a href="#定义解读-3" class="headerlink" title="定义解读"></a>定义解读</h3><p>在继承体系中，子类中可以增加自己特有的方法，也可以实现父类的抽象方法，但是不能重写父类的非抽象方法，否则该继承关系就不是一个正确的继承关系。</p>
<h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><p>可以检验继承使用的正确性，约束继承在使用上的泛滥。</p>
<h3 id="代码讲解-5"><a href="#代码讲解-5" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>在这里用一个简单的长方形与正方形的例子讲解一下里氏替换原则。</p>
<h4 id="需求点-5"><a href="#需求点-5" class="headerlink" title="需求点"></a>需求点</h4><p>创建两个类：长方形和正方形，都可以设置宽高（边长），也可以输出面积大小。</p>
<h4 id="不好的设计-5"><a href="#不好的设计-5" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>首先声明一个长方形类，然后让正方形类继承于长方形。</p>
<p>长方形类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//================== Rectangle.h ==================</span><br><span class="line">@interface Rectangle : NSObject &#123;</span><br><span class="line">    @protected double _width;</span><br><span class="line">    @protected double _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置宽高</span><br><span class="line">- (void)setWidth:(double)width;</span><br><span class="line">- (void)setHeight:(double)height;</span><br><span class="line"></span><br><span class="line">// 获取宽高</span><br><span class="line">- (double)width;</span><br><span class="line">- (double)height;</span><br><span class="line"></span><br><span class="line">// 获取面积</span><br><span class="line">- (double)getArea;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Rectangle.m ==================</span><br><span class="line">@implementation Rectangle</span><br><span class="line"></span><br><span class="line">- (void)setWidth:(double)width &#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHeight:(double)height &#123;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)width &#123;</span><br><span class="line">    return _width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)height &#123;</span><br><span class="line">    return _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)getArea &#123;</span><br><span class="line">    return _width * _height;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>正方形类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//================== Square.h ==================</span><br><span class="line">@interface Square : Rectangle</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Square.m ==================</span><br><span class="line"></span><br><span class="line">@implementation Square</span><br><span class="line"></span><br><span class="line">- (void)setWidth:(double)width &#123;</span><br><span class="line">    _width = width;</span><br><span class="line">    _height = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHeight:(double)height &#123;</span><br><span class="line">    _width = height;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>可以看到，正方形类继承了长方形类以后，为了保证边长永远是相等的，特意在两个 set 方法里面强制将宽和高都设置为传入的值，也就是重写了父类 <strong>Rectangle</strong> 的两个 set 方法。但是里氏替换原则里规定，子类不能重写父类的方法，所以上面的设计是违反该原则的。</p>
<p>而且里氏替换原则里面所说：子类对象能够替换父类对象，而程序执行效果不变。我们通过一个例子来看一下上面的设计是否符合。</p>
<p>在客户端类写一个方法：传入一个 <strong>Rectangle</strong> 类型并返回它的面积：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (double)calculateAreaOfRect:(Rectangle *)rect &#123;</span><br><span class="line">    return rect.getArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先用 <strong>Rectangle</strong> 对象试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle *rect = [[Rectangle alloc] init];</span><br><span class="line">rect.width = 10;</span><br><span class="line">rect.height = 20;</span><br><span class="line">    </span><br><span class="line">double rectArea = [self calculateAreaOfRect:rect];  // output:200</span><br></pre></td></tr></table></figure>
<p>长宽分别设置为10、20以后，结果输出200，没有问题。</p>
<p>现在我们使用 <strong>Rectangle</strong> 的子类 <strong>Square</strong> 的对象替换原来的 <strong>Rectangle</strong> 对象，看一下结果如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Square *square = [[Square alloc] init];</span><br><span class="line">square.width = 10;</span><br><span class="line">square.height = 20;</span><br><span class="line">    </span><br><span class="line">double squareArea = [self calculateAreaOfRect:square];  // output:400</span><br></pre></td></tr></table></figure>
<p>结果输出为400，结果不一致，再次说明了上述设计不符合里氏替换原则，因为子类的对象 <strong>square</strong> 替换父类的对象 <strong>rect</strong> 以后，程序执行的结果变了。</p>
<p>不符合里氏替换原则就说明该继承关系不是正确的继承关系，也就是说正方形类不能继承于长方形类，程序需要重新设计。</p>
<p>我们现在看一下比较好的设计：</p>
<h4 id="较好的设计-5"><a href="#较好的设计-5" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>既然正方形不能继承于长方形，那么是否可以让二者都继承于其他的父类呢？答案是可以的。</p>
<p>既然要继承于其他的父类，它们这个父类肯定具备这两种形状共同的特点：有4个边。那么我们就定义一个四边形的类：<strong>Quadrangle</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//================== Quadrangle.h ==================</span><br><span class="line">@interface Quadrangle : NSObject &#123;</span><br><span class="line">    @protected double _width;</span><br><span class="line">    @protected double _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setWidth:(double)width;</span><br><span class="line">- (void)setHeight:(double)height;</span><br><span class="line"></span><br><span class="line">- (double)width;</span><br><span class="line">- (double)height;</span><br><span class="line"></span><br><span class="line">- (double)getArea;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接着，让 <strong>Rectangle</strong> 类和 <strong>Square</strong> 继承于它：</p>
<p><strong>Rectangle</strong> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//================== Rectangle.h ==================</span><br><span class="line">#import &quot;Quadrangle.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Rectangle : Quadrangle</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Rectangle.m ==================</span><br><span class="line">@implementation Rectangle</span><br><span class="line"></span><br><span class="line">- (void)setWidth:(double)width &#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHeight:(double)height &#123;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)width &#123;</span><br><span class="line">    return _width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)height &#123;</span><br><span class="line">    return _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)getArea &#123;</span><br><span class="line">    return _width * _height;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>Square</strong> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//================== Square.h ==================</span><br><span class="line">@interface Square : Quadrangle &#123;</span><br><span class="line">    @protected double _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setSideLength:(double)sideLength;</span><br><span class="line"></span><br><span class="line">-(double)sideLength;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//================== Square.m ==================</span><br><span class="line">@implementation Square</span><br><span class="line"></span><br><span class="line">-(void)setSideLength:(double)sideLength &#123;    </span><br><span class="line">    _sideLength = sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(double)sideLength &#123;</span><br><span class="line">    return _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setWidth:(double)width &#123;</span><br><span class="line">    _sideLength = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHeight:(double)height &#123;</span><br><span class="line">    _sideLength = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)width &#123;</span><br><span class="line">    return _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)height &#123;</span><br><span class="line">    return _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (double)getArea &#123;</span><br><span class="line">    return _sideLength * _sideLength;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<strong>Rectangle</strong> 和 <strong>Square</strong> 类都以自己的方式实现了父类 <strong>Quadrangle</strong> 的公共方法。而且由于 <strong>Square</strong> 的特殊性，它也声明了自己独有的成员变量 _sideLength 以及其对应的公共方法。</p>
<blockquote>
<p>注意，这里 <strong>Rectange</strong> 和 <strong>Square</strong> 并不是重写了其父类的公共方法，而是实现了其抽象方法。</p>
</blockquote>
<p>下面来看一下这两个设计的 UML 类图，可以更形象地看出两种设计上的区别：</p>
<h4 id="UML-类图对比-5"><a href="#UML-类图对比-5" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践里氏替换原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190217205237.jpg" alt=""></p>
<p>实践了里氏替换原则：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190217205254.jpg" alt=""></p>
<h3 id="如何实践-5"><a href="#如何实践-5" class="headerlink" title="如何实践"></a>如何实践</h3><p>里氏替换原则是对继承关系的一种检验：检验是否真正符合继承关系，以避免继承的滥用。因此，在使用继承之前，需要反复思考和确认该继承关系是否正确，或者当前的继承体系是否还可以支持后续的需求变更，如果无法支持，则需要及时重构，采用更好的方式来设计程序。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>关于这几个设计原则还有最后一点需要强调的是：设计原则是设计模式的基石，但是很难在实际开发中的某个设计中全部都满足这些设计原则。因此我们需要抓住具体设计场景的特殊性，有选择地遵循最合适的设计原则。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#设计模式">
    <span class="tag-code">设计模式</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/09/10/工具类：FPSDisplay/">
        <span class="nav-arrow">← </span>
        
          工具类：FPSDisplay
        
      </a>
    
    
      <a class="nav-right" href="/2018/09/16/面向对象设计模式（二）：创建型设计模式/">
        
          面向对象设计模式（二）：创建型设计模式
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#前言"><span class="toc-nav-text">前言</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#六大设计原则"><span class="toc-nav-text">六大设计原则</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则一：开闭原则（Open-Close-Principle）"><span class="toc-nav-text">原则一：开闭原则（Open Close Principle）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义的解读"><span class="toc-nav-text">定义的解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践"><span class="toc-nav-text">如何实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则二：单一职责原则（Single-Responsibility-Principle）"><span class="toc-nav-text">原则二：单一职责原则（Single Responsibility Principle）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义-1"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义的解读-1"><span class="toc-nav-text">定义的解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点-1"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解-1"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点-1"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计-1"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计-1"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比-1"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践-1"><span class="toc-nav-text">如何实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则三：依赖倒置原则（Dependency-Inversion-Principle）"><span class="toc-nav-text">原则三：依赖倒置原则（Dependency Inversion Principle）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义-2"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义解读"><span class="toc-nav-text">定义解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点-2"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解-2"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点-2"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计-2"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#问题一："><span class="toc-nav-text">问题一：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#问题二："><span class="toc-nav-text">问题二：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计-2"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#假设1：后台的开发语言改成了-GO-语言"><span class="toc-nav-text">假设1：后台的开发语言改成了 GO 语言</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#假设2：后期老板要求做移动端的-APP（需要iOS和安卓的开发者）"><span class="toc-nav-text">假设2：后期老板要求做移动端的 APP（需要iOS和安卓的开发者）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比-2"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践-2"><span class="toc-nav-text">如何实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则四：接口分离原则（Interface-Segregation-Principle）"><span class="toc-nav-text">原则四：接口分离原则（Interface Segregation Principle）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义-3"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义解读-1"><span class="toc-nav-text">定义解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点-3"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解-3"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点-3"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计-3"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计-3"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比-3"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践-3"><span class="toc-nav-text">如何实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则五：迪米特法则（Law-of-Demeter）"><span class="toc-nav-text">原则五：迪米特法则（Law of Demeter）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义-4"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义解读-2"><span class="toc-nav-text">定义解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点-4"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解-4"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点-4"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计-4"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计-4"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比-4"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践-4"><span class="toc-nav-text">如何实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#原则六：里氏替换原则（Liskov-Substitution-Principle）"><span class="toc-nav-text">原则六：里氏替换原则（Liskov Substitution Principle）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义-5"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#定义解读-3"><span class="toc-nav-text">定义解读</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优点-5"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码讲解-5"><span class="toc-nav-text">代码讲解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#需求点-5"><span class="toc-nav-text">需求点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#不好的设计-5"><span class="toc-nav-text">不好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#较好的设计-5"><span class="toc-nav-text">较好的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UML-类图对比-5"><span class="toc-nav-text">UML 类图对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何实践-5"><span class="toc-nav-text">如何实践</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#最后的话"><span class="toc-nav-text">最后的话</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/09/15/面向对象设计模式（一）：六大设计原则/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "面向对象设计模式（一）：六大设计原则",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2018/09/15/面向对象设计模式（一）：六大设计原则/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>