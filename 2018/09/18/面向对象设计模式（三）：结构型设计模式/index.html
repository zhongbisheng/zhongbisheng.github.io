<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Wendell&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      面向对象设计模式（三）：结构型设计模式 | Wendell&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://oindk07nf.qnssl.com/atom-one-dark.css" media="screen" type="text/css">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Wendell's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>面向对象设计模式（三）：结构型设计模式</h2>
  <p class="post-date">2018-09-18</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>本篇是面向对象设计系列文章的第三篇，讲解的是设计模式中的结构型模式：</p>
<ul>
<li>外观模式</li>
<li>适配器模式</li>
<li>桥接模式</li>
<li>代理模式</li>
<li>装饰者模式</li>
<li>享元模式</li>
</ul>
<h1 id="一、外观模式（Facade）"><a href="#一、外观模式（Facade）" class="headerlink" title="一、外观模式（Facade）"></a>一、外观模式（Facade）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。外观模式又称为门面模式，它是一种结构型设计模式。</p>
</blockquote>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>子系统随着业务复杂度的提升而变得越来越复杂，客户端需要某些子系统共同协作来完成某个任务；</li>
<li>在多层结构的系统中，使用外观对象可以作为每层的入口来简化层间的调用。</li>
</ul>
<p>在谈起外观模式的时候，常常是指对一个复杂的（旧）代码库在不改变其内在的情况下，包装一层易于调用的表层 API。</p>
<h2 id="成员与类图"><a href="#成员与类图" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>外观模式包括客户端共有三个成员：</p>
<ul>
<li>客户端类（Client）：客户端是意图操作子系统的类，它与外观类直接接触；</li>
<li>外观类（Facade）：外观类知晓各个子系统的职责和接口，封装子系统的接口并提供给客户端；</li>
<li>子系统类（SubSystem）：子系统类实现子系统的功能，对外观类一无所知。</li>
</ul>
<p>下面通过类图来看一下各个成员之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190224200115.jpg" alt=""></p>
<blockquote>
<p>上图中的 <code>method1&amp;2()</code> 方法就是调用 <strong>SubSystem1</strong> 和 <strong>SubSystem2</strong> 的 <code>method1()</code> 和 <code>method1()</code> 方法。同样适用于 <code>method2&amp;3()</code>。</p>
</blockquote>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>模拟一个智能家居系统。这个智能家居系统可以用一个中央遥控器操作其所接入的一些家电：台灯、音箱、空调等等。</p>
<p>在这里我们简单操纵几个设备：</p>
<ul>
<li>空调</li>
<li>CD Player</li>
<li>DVD Player</li>
<li>音箱</li>
<li>投影仪</li>
</ul>
<p>有时候，我们需要某个设备可以一次执行两个不同的操作，也可能会需要多个设备共同协作来执行一些任务。比如：</p>
<p>假设我们可以用遥控器直接开启热风，那么实际上就是两个步骤：</p>
<ol>
<li>开启空调</li>
<li>空调切换为热风模式</li>
</ol>
<p>我们把这两个步骤用一个操作包含起来，一步到位。像这样简化操作步骤的场景比较适合使用外观模式。</p>
<p>同样的，我们想听歌的话，需要四个步骤：</p>
<ol>
<li>开启 CD Player</li>
<li>开启音箱</li>
<li>连接 CD Player 和 音箱</li>
<li>播放 CD Player</li>
</ol>
<p>这些步骤我们也可以装在单独的一个接口里面。</p>
<p>类似的，如果我们想看 DVD 的话，步骤会更多，因为 DVD 需要同时输出声音和影像：</p>
<ol>
<li>开启 DVD Player；</li>
<li>开启音箱；</li>
<li>音箱与 DVD Player 连接；</li>
<li>开启投影仪；</li>
<li>投影仪与 DVD Player；</li>
<li>播放 DVD Player。</li>
</ol>
<p>这些接口也可以装在一个单独的接口里。</p>
<p>最后，如果我们要出门，需要关掉所有家用电器，也不需要一个一个将它们关掉，也只需要一个关掉的总接口就好了，因为这个关掉的总接口里面可以包含所有家用电器的关闭接口。</p>
<p>因此，这些设备可以看做是该智能家居系统的子系统，而这个遥控器则扮演的是外观类的角色。</p>
<p>下面我们用代码来看一下如何实现这些设计。</p>
<p>因为所有家电电器都有开启和关闭的操作，所有我们先创建一个家用电器的基类 <strong>HomeDevice</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDevice.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HomeDevice</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接电源</span></span><br><span class="line">- (<span class="keyword">void</span>)on;</span><br><span class="line"><span class="comment">// 关闭电源</span></span><br><span class="line">- (<span class="keyword">void</span>)off;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后是继承它的所有家用电器类：</p>
<p><strong>AirConditioner</strong> 空调类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== AirConditioner.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AirConditioner</span> : <span class="title">HomeDevice</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高温模式</span></span><br><span class="line">- (<span class="keyword">void</span>)startHighTemperatureMode;</span><br><span class="line"><span class="comment">// 常温模式</span></span><br><span class="line">- (<span class="keyword">void</span>)startMiddleTemperatureMode;</span><br><span class="line"><span class="comment">// 低温模式</span></span><br><span class="line">- (<span class="keyword">void</span>)startLowTemperatureMode;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>CDPlayer</strong> 类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== CDPlayer.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CDPlayer</span> : <span class="title">HomeDevice</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)play;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>DVDPlayer</strong> 类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== DVDPlayer.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DVDPlayer</span> : <span class="title">HomeDevice</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)play;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>VoiceBox</strong> 音箱类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== VoiceBox.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">CDPlayer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">DVDPlayer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VoiceBox</span> : <span class="title">HomeDevice</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与CDPlayer连接</span></span><br><span class="line">- (<span class="keyword">void</span>)connetCDPlayer:(CDPlayer *)cdPlayer;</span><br><span class="line"><span class="comment">// 与CDPlayer断开连接</span></span><br><span class="line">- (<span class="keyword">void</span>)disconnetCDPlayer:(CDPlayer *)cdPlayer;</span><br><span class="line"><span class="comment">// 与DVD Player连接</span></span><br><span class="line">- (<span class="keyword">void</span>)connetDVDPlayer:(DVDPlayer *)dvdPlayer;</span><br><span class="line"><span class="comment">// 与DVD Player断开连接</span></span><br><span class="line">- (<span class="keyword">void</span>)disconnetDVDPlayer:(DVDPlayer *)dvdPlayer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>Projecter</strong> 投影仪类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Projecter.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Projecter</span> : <span class="title">HomeDevice</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与DVD Player连接</span></span><br><span class="line">- (<span class="keyword">void</span>)connetDVDPlayer:(DVDPlayer *)dvdPlayer;</span><br><span class="line"><span class="comment">// 与DVD Player断开连接</span></span><br><span class="line">- (<span class="keyword">void</span>)disconnetDVDPlayer:(DVDPlayer *)dvdPlayer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：音箱是可以连接 CD Player 和 DVD Player 的，而投影仪只能连接 DVD Player。</p>
</blockquote>
<p>现在我们把所有的家用电器类和他们的接口都定义好了，下面我们看一下该实例的外观类 <strong>HomeDeviceManager</strong> 如何设计。</p>
<p>首先我们看一下客户端期望外观类实现的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HomeDeviceManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===== 关于空调的接口 =====</span></span><br><span class="line"><span class="comment">// 空调吹冷风</span></span><br><span class="line">- (<span class="keyword">void</span>)coolWind;</span><br><span class="line"><span class="comment">// 空调吹热风</span></span><br><span class="line">- (<span class="keyword">void</span>)warmWind;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===== 关于CD Player的接口 =====</span></span><br><span class="line"><span class="comment">// 播放CD</span></span><br><span class="line">- (<span class="keyword">void</span>)playMusic;</span><br><span class="line"><span class="comment">// 关掉音乐</span></span><br><span class="line">- (<span class="keyword">void</span>)offMusic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===== 关于DVD Player的接口 =====</span></span><br><span class="line"><span class="comment">// 播放DVD</span></span><br><span class="line">- (<span class="keyword">void</span>)playMovie;</span><br><span class="line"><span class="comment">// 关闭DVD</span></span><br><span class="line">- (<span class="keyword">void</span>)offMoive;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===== 关于总开关的接口 =====</span></span><br><span class="line"><span class="comment">// 打开全部家用电器</span></span><br><span class="line">- (<span class="keyword">void</span>)allDeviceOn;</span><br><span class="line"><span class="comment">// 关闭所有家用电器</span></span><br><span class="line">- (<span class="keyword">void</span>)allDeviceOff;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的接口分为了四大类，分别是：</p>
<ul>
<li>关于空调的接口；</li>
<li>关于 CD Player 的接口；</li>
<li>关于 DVD Player 的接口；</li>
<li>关于总开关的接口。</li>
</ul>
<p>在看这些接口时如何实现的之前，我们先看一下外观类是如何保留这些子系统类的实例的。在该代码示例中，这些子系统类的实例在外观类的构造方法里被创建，而且作为外观类的成员变量被保存了下来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HomeDeviceManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *registeredDevices; <span class="comment">// 所有注册(被管理的)的家用电器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AirConditioner *airconditioner;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CDPlayer *cdPlayer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) DVDPlayer *dvdPlayer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) VoiceBox *voiceBox;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Projecter *projecter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HomeDeviceManager</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _airconditioner = [[AirConditioner alloc] init];</span><br><span class="line">        _cdPlayer = [[CDPlayer alloc] init];</span><br><span class="line">        _dvdPlayer = [[DVDPlayer alloc] init];</span><br><span class="line">        _voiceBox = [[VoiceBox alloc] init];</span><br><span class="line">        _projecter = [[Projecter alloc] init];</span><br><span class="line">        _registeredDevices = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[_airconditioner,</span><br><span class="line">                                                              _cdPlayer,</span><br><span class="line">                                                              _dvdPlayer,</span><br><span class="line">                                                              _voiceBox,</span><br><span class="line">                                                              _projecter]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其中 registeredDevices 这个成员变量是一个数组，它包含了所有和这个外观类实例关联的子系统实例。</p>
<p>子系统与外观类的关联实现方式不止一种，不作为本文研究重点，现在只需知道外观类保留了这些子系统的实例即可。按照顺序，我们首先看一下关于空调的接口实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空调吹冷风</span></span><br><span class="line">- (<span class="keyword">void</span>)coolWind &#123;</span><br><span class="line">    [_airconditioner on];</span><br><span class="line">    [_airconditioner startLowTemperatureMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空调吹热风</span></span><br><span class="line">- (<span class="keyword">void</span>)warmWind &#123;</span><br><span class="line">    [_airconditioner on];</span><br><span class="line">    [_airconditioner startHighTemperatureMode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>吹冷风和吹热风的接口都包含了空调实例的两个接口，第一个都是开启空调，第二个则是对应的冷风和热风的接口。</p>
<p>我们接着看关于 CD Player 的接口实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.m ==================</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playMusic &#123; </span><br><span class="line">    <span class="comment">// 1. 开启CDPlayer开关</span></span><br><span class="line">    [_cdPlayer on];</span><br><span class="line">    <span class="comment">// 2. 开启音箱</span></span><br><span class="line">    [_voiceBox on];</span><br><span class="line">    <span class="comment">// 3. 音响与CDPlayer连接</span></span><br><span class="line">    [_voiceBox connetCDPlayer:_cdPlayer];</span><br><span class="line">    <span class="comment">// 4. 播放CDPlayer</span></span><br><span class="line">    [_cdPlayer play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关掉音乐</span></span><br><span class="line">- (<span class="keyword">void</span>)offMusic &#123;</span><br><span class="line">   <span class="comment">// 1. 切掉与音箱的连接</span></span><br><span class="line">    [_voiceBox disconnetCDPlayer:_cdPlayer];</span><br><span class="line">    <span class="comment">// 2. 关掉音箱</span></span><br><span class="line">    [_voiceBox off];</span><br><span class="line">    <span class="comment">// 3. 关掉CDPlayer</span></span><br><span class="line">    [_cdPlayer off];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的场景分析中提到过，听音乐这个指令要分四个步骤：CD Player 和音箱的开启，二者的连接，以及播放 CD Player，这也比较符合实际生活中的场景。关掉音乐也是先断开连接再切断电源（虽然直接切断电源也可以）。</p>
<p>接下来我们看一下关于 DVD Player 的接口的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.m ==================</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playMovie &#123;</span><br><span class="line">    <span class="comment">// 1. 开启DVD player</span></span><br><span class="line">    [_dvdPlayer on];</span><br><span class="line">    <span class="comment">// 2. 开启音箱</span></span><br><span class="line">    [_voiceBox on];</span><br><span class="line">    <span class="comment">// 3. 音响与DVDPlayer连接</span></span><br><span class="line">    [_voiceBox connetDVDPlayer:_dvdPlayer];</span><br><span class="line">    <span class="comment">// 4. 开启投影仪</span></span><br><span class="line">    [_projecter on];</span><br><span class="line">    <span class="comment">// 5.投影仪与DVDPlayer连接</span></span><br><span class="line">    [_projecter connetDVDPlayer:_dvdPlayer];</span><br><span class="line">    <span class="comment">// 6. 播放DVDPlayer</span></span><br><span class="line">    [_dvdPlayer play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)offMoive &#123;</span><br><span class="line">    <span class="comment">// 1. 切掉音箱与DVDPlayer连接</span></span><br><span class="line">    [_voiceBox disconnetDVDPlayer:_dvdPlayer];</span><br><span class="line">    <span class="comment">// 2. 关掉音箱</span></span><br><span class="line">    [_voiceBox off];</span><br><span class="line">    <span class="comment">// 3. 切掉投影仪与DVDPlayer连接</span></span><br><span class="line">    [_projecter disconnetDVDPlayer:_dvdPlayer];</span><br><span class="line">    <span class="comment">// 4. 关掉投影仪</span></span><br><span class="line">    [_projecter off];</span><br><span class="line">    <span class="comment">// 5. 关掉DVDPlayer</span></span><br><span class="line">    [_dvdPlayer off];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 DVD Player 要同时连接音箱和投影仪，所以这两个接口封装的子系统接口相对于 CD Player 的更多一些。</p>
<p>最后我们看一下关于总开关的接口的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HomeDeviceManager.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开全部家用电器</span></span><br><span class="line">- (<span class="keyword">void</span>)allDeviceOn &#123;</span><br><span class="line">    [_registeredDevices enumerateObjectsUsingBlock:^(HomeDevice *device, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [device on];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭所有家用电器</span></span><br><span class="line">- (<span class="keyword">void</span>)allDeviceOff &#123;</span><br><span class="line">    [_registeredDevices enumerateObjectsUsingBlock:^(HomeDevice *device, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [device off];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个接口是为了方便客户端开启和关闭所有设备的，有这两个接口的话，用户就不用一一开启或关闭多个设备了。</p>
<p>关于这两个接口的实现：</p>
<p>上文说过，该外观类通过一个数组成员变量 registeredDevices 来保存所有可操作的设备。所以如果我们需要开启或关闭所有的设备就可以遍历这个数组并向每个元素调用 <code>on</code> 或 <code>off</code> 方法。因为这些元素都继承于  <strong>HomeDevice</strong>，也就是都有 <code>on</code> 或 <code>off</code> 方法。</p>
<p>这样做的好处是，我们不需要单独列出所有设备来分别调用它们的接口；而且后面如果添加或者删除某些设备的话也不需要修改这两个接口的实现了。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护；</li>
<li>符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。</p>
<h2 id="Objective-C-的实践"><a href="#Objective-C-的实践" class="headerlink" title="Objective-C 的实践"></a>Objective-C 的实践</h2><p>Objective-C：<strong>SDWebImage</strong> 封装了负责图片下载的类和负责图片缓存的类，而外部仅向客户端暴露了简约的下载图片的接口。</p>
<h1 id="二、适配器模式（Adapter）"><a href="#二、适配器模式（Adapter）" class="headerlink" title="二、适配器模式（Adapter）"></a>二、适配器模式（Adapter）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式又分为对象适配器和类适配器两种：</p>
<ul>
<li>对象适配器：利用组合的方式将请求转发给被适配者；</li>
<li>类适配器：通过适配器类多重继承目标接口和被适配者，将目标方法的调用转换到调用被适配者的方法。</li>
</ul>
<h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>想使用一个已经存在的类，但是这个类的接口不符合我们的要求，原因可能是和系统内的其他需求合作的类不兼容；</li>
<li>想创建一个功能上可以复用的类，这个类可能需要和未来某些未知接口的类一起工作。</li>
</ul>
<h2 id="成员与类图-1"><a href="#成员与类图-1" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>适配器模式有三个成员：</p>
<ul>
<li>目标（Target）：客户端希望直接接触的类，给客户端提供了调用的接口；</li>
<li>被适配者（Adaptee）：是已经存在的类，即需要被适配的类；</li>
<li>适配器（Adapter）：对 Adaptee 的接口和 Target 的接口进行适配。</li>
</ul>
<p>如上文所说，适配器模式分为类适配器模式和对象适配器模式，因此这里同时提供这两种细分模式的 UML 类图。</p>
<p>对象适配器模式：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190225100503.jpg" alt=""></p>
<blockquote>
<p>对象适配器中，被适配者的对象被适配器所持有。当适配器的 <code>request</code> 方法被调用时，在这个方法内部再调用被适配者对应的方法。</p>
</blockquote>
<p>类适配器模式：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190225100520.jpg" alt=""></p>
<blockquote>
<p>类适配器中采用了多继承的方式：适配器同时继承了目标类和被适配者类，也就都持有了二者的方法。</p>
</blockquote>
<p>多继承在 Objective-C 中可以通过遵循多个协议来实现，在本模式的代码示例中只使用对象适配器来实现。</p>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>场景概述：</p>
<p>模拟一个替换缓存组件的场景：目标客户端已经依赖于旧的缓存组件的接口，而后来发现有一个新的缓存组件的性能更好一些，需要将旧的缓存组件替换成新的缓存组件，但是新的缓存组件的接口与旧的缓存接口不一致，所以目前来看客户端是无法直接与新缓存组件一起工作的。</p>
<p>场景分析：</p>
<p>由于客户端在很多地方依赖了旧缓存组件的接口，将这些地方的接口都换成新缓存组件的接口会比较麻烦，而且万一后面还要换回旧缓存组件或者再换成另外一个新的缓存组件的话就还要做重复的事情，这显然是不够优雅的。</p>
<p>因此该场景比较适合使用适配器模式：创建一个适配器，让原本与旧缓存接口的客户端可以与新缓存组件一起工作。</p>
<p>在这里，新的缓存组件就是 <strong>Adaptee</strong>，旧的缓存组件（接口）就是 <strong>Target</strong>，因为它是直接和客户端接触的。而我们需要创建一个适配器类 <strong>Adaptor</strong> 来让客户端与新缓存组件一起工作。下面用代码看一下上面的问题如何解决：</p>
<p>首先我们创建旧缓存组件，并让客户端正常使用它。先创建旧缓存组件的接口 <strong><em>OldCacheProtocol</em></strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== OldCacheProtocol.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">OldCacheProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)old_saveCacheObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)old_getCacheObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>再简单创建一个缓存组件类 <strong>OldCache</strong>，它实现了 <strong><em>OldCacheProtocol</em></strong> 接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== OldCache.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OldCache</span> : <span class="title">NSObject</span> &lt;<span class="title">OldCacheProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== OldCache.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OldCache</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)old_saveCacheObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"saved cache by old cache object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)old_getCacheObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"get cache by old cache object"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了让读者区分方便，将新旧两个缓存组件取名为 <strong>NewCache</strong> 和 <strong>OldCache</strong>。实现代码也比较简单，因为不是本文介绍的重点，只需区分接口名称即可。</p>
</blockquote>
<p>现在我们让客户端来使用这个旧缓存组件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;OldCacheProtocol&gt;cache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 使用旧缓存</span></span><br><span class="line">    [<span class="keyword">self</span> useOldCache];</span><br><span class="line">    <span class="comment">// 使用缓存组件操作</span></span><br><span class="line">    [<span class="keyword">self</span> saveObject:<span class="string">@"cache"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化旧缓存并保存在``cache``属性里</span></span><br><span class="line">- (<span class="keyword">void</span>)useOldCache &#123;</span><br><span class="line">    <span class="keyword">self</span>.cache = [[OldCache alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cache对象</span></span><br><span class="line">- (<span class="keyword">void</span>)saveObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [<span class="keyword">self</span>.cache old_saveCacheObject:object forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在这里的客户端就是 <strong>ViewController</strong>，它持有一个遵从 <strong><em>OldCacheProtocol</em></strong> 协议的实例，也就是说它目前依赖于 <strong><em>OldCacheProtocol</em></strong> 的接口；</li>
<li><code>useOldCache</code> 方法用来实例化旧缓存并保存在 cache 属性里；</li>
<li><code>saveObject:forKey:</code> 方法是真正使用 cache 对象来保存缓存。</li>
</ul>
</blockquote>
<p>运行并打印一下结果输出是：saved cache by old cache object。现在看来客户端使用旧缓存是没有问题的。</p>
<p>而现在我们要加入新的缓存组件了：首先定义新缓存组件的接口 <strong><em>NewCacheProtocol</em></strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== NewCacheProtocol.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NewCacheProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)new_saveCacheObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)new_getCacheObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<strong><em>NewCacheProtocol</em></strong> 与 <strong><em>OldCacheProtocol</em></strong> 接口大致是相似的，但是名称还是不同，这里使用了不同的方法前缀做了区分。</p>
<p>接着看一下新缓存组件是如何实现这个接口的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== NewCache.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NewCache</span> : <span class="title">NSObject</span> &lt;<span class="title">NewCacheProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== NewCache.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NewCache</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)new_saveCacheObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"saved cache by new cache object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)new_getCacheObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"saved cache by new cache object"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>现在我们拿到了新的缓存组件，但是客户端目前依赖的是旧的接口，因此适配器应该上场了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Adaptor.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Adaptor</span> : <span class="title">NSObject</span> &lt;<span class="title">OldCacheProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNewCache:(NewCache *)newCache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//================== Adaptor.m ==================</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Adaptor</span></span></span><br><span class="line">&#123;</span><br><span class="line">    NewCache *_newCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNewCache:(NewCache *)newCache &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _newCache = newCache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)old_saveCacheObject:(<span class="keyword">id</span>)obj forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// transfer responsibility to new cache object</span></span><br><span class="line">    [_newCache new_saveCacheObject:obj forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)old_getCacheObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// transfer responsibility to new cache object</span></span><br><span class="line">    <span class="keyword">return</span> [_newCache new_getCacheObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先，适配器也实现了旧缓存组件的接口，目的是让它也可以接收到客户端操作旧缓存组件的方法；</li>
<li>然后，适配器的构造方法里面需要传入新组件类的实例，目的是在收到客户端操作旧缓存组件的命令后，将该命令转发给新缓存组件类，并调用其对应的方法；</li>
<li>最后我们看一下适配器类是如何实现两个旧缓存组件的接口的：在 <code>old_saveCacheObject:forKey:</code> 方法中，让新缓存组件对象调用对应的 <code>new_saveCacheObject:forKey:</code> 方法；同样地，在 <code>old_getCacheObjectForKey:</code> 方法中，让新缓存组件对象调用对应的 <code>new_getCacheObjectForKey:</code> 方法。</li>
</ul>
</blockquote>
<p>这样一来，适配器就定义好了。那么最后我们看一下在客户端里面是如何使用适配器的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ==================</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 使用新缓存组件</span></span><br><span class="line">    [<span class="keyword">self</span> useNewCache];</span><br><span class="line">    [<span class="keyword">self</span> saveObject:<span class="string">@"cache"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)useOldCache &#123;</span><br><span class="line">    <span class="keyword">self</span>.cache = [[OldCache alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新缓存组件</span></span><br><span class="line">- (<span class="keyword">void</span>)useNewCache &#123;</span><br><span class="line">    <span class="keyword">self</span>.cache = [[Adaptor alloc] initWithNewCache:[[NewCache alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cache对象</span></span><br><span class="line">- (<span class="keyword">void</span>)saveObject:(<span class="keyword">id</span>)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    [<span class="keyword">self</span>.cache old_saveCacheObject:object forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，在客户端里面，只需要改一处就可以了：将我们定义好的适配器类保存在原来的 cache 属性中就可以了（<code>useNewCache</code> 方法的实现）。而真正操作缓存的方法 <code>saveObject:forKey:</code> 不需要有任何改动。</p>
</blockquote>
<p>我们可以看到，使用适配器模式，客户端调用旧缓存组件接口的方法都不需要改变，只需稍作处理，就可以在新缓存组件中来回切换，也不需要原来客户端对缓存的操作。</p>
<p>而之所以可以做到这么灵活，其实也是因为在一开始客户端只是依赖了旧缓存组件类所实现的接口，而不是旧缓存组件类的类型。有心的读者可能注意到了，上面 <strong>viewController</strong> 的属性是 <code>@property (nonatomic, strong) id&lt;OldCacheProtocol&gt;cache;</code>。正因为如此，我们新建的适配器实例才能直接用在这里，因为适配器类也是实现了 <strong><em>OldCacheProtocol</em></strong> 接口。相反，如果我们的 cache 属性是这么写的：<code>@property (nonatomic, strong) OldCache *cache;</code>，即客户端依赖了旧缓存组件的类型，那么我们的适配器就无法这么容易地放在这里了。因此为了我们的程序在将来可以更好地修改和扩展，依赖接口是一个前提。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul>
<li>符合开闭原则，使用适配器而不需要改变现有类，提高类的复用性；</li>
<li>目标类和适配器类解耦，提高程序扩展性。</li>
</ul>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>增加了系统的复杂性</p>
<h1 id="三、桥接模式"><a href="#三、桥接模式" class="headerlink" title="三、桥接模式"></a>三、桥接模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<p>桥接模式的核心是两个抽象以组合的形式关联到一起，从而他们的实现是互不依赖的。</p>
<h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><p>如果一个系统存在两个独立变化的维度，而且这两个维度都需要进行扩展的时候比较合适使用桥接模式。</p>
<h2 id="成员与类图-2"><a href="#成员与类图-2" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>桥接模式一共只有三个成员：</p>
<ul>
<li>抽象类（Abstraction）：维护一个实现部分的对象的引用，并声明调用实现部分的对象的接口；</li>
<li>扩展抽象类（RefinedAbstraction）：定义跟实际业务相关的方法；</li>
<li>实现类接口（Implementor）：定义实现部分的接口；</li>
<li>具体实现类（ConcreteImplementor）：具体实现类是实现类接口的对象。</li>
</ul>
<p>下面通过类图来看一下各个成员之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190226101243.jpg" alt=""></p>
<blockquote>
<p>从类图中可以看出 <strong>Abstraction</strong> 持有 <strong>Implementor</strong>，但是二者的实现类互不依赖。这就是桥接模式的核心。</p>
</blockquote>
<h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><p>创建一些不同的形状，这些形状带有不同的颜色。</p>
<p>三种形状：</p>
<ul>
<li>正方形</li>
<li>长方形</li>
<li>圆形</li>
</ul>
<p>三种颜色：</p>
<ul>
<li>红色</li>
<li>绿色</li>
<li>蓝色</li>
</ul>
<p>根据上述需求，可能有的朋友会这么设计：</p>
<ul>
<li>正方形<ul>
<li>红色正方形</li>
<li>绿色正方形</li>
<li>蓝色正方形</li>
</ul>
</li>
<li>长方形<ul>
<li>红色长方形</li>
<li>绿色长方形</li>
<li>蓝色长方形</li>
</ul>
</li>
<li>圆形<ul>
<li>红色圆形</li>
<li>绿色圆形</li>
<li>蓝色圆形</li>
</ul>
</li>
</ul>
<p>这样的设计确实可以实现上面的需求。但是设想一下，如果后来增加了一种颜色或者形状的话，是不是要多出来很多类？如果形状的种类数是 m，颜色的种类数是 n，以这种方式创建的总类数就是 m*n，当 m 或 n 非常大的时候，它们相乘的结果就会变得很大。</p>
<p>我们观察一下这个场景：形状和颜色这二者是没有关联性的，二者可以独立扩展和变化，这样的组合比较适合用桥接模式来做。</p>
<p>根据上面提到的桥接模式的成员：</p>
<ul>
<li>抽象类就是图形的抽象类</li>
<li>扩展抽象类就是继承图形抽象类的子类：各种形状</li>
<li>实现类接口就是颜色接口</li>
<li>具体实现类就是继承颜色接口的类：各种颜色</li>
</ul>
<p>下面我们用代码看一下该如何设计。</p>
<p>首先我们创建形状的基类 <strong>Shape</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Shape.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Color</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Shape</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)renderColor:(Color *)color;</span><br><span class="line">- (<span class="keyword">void</span>)show;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Shape.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Shape</span> ()</span></span><br><span class="line">    </span><br><span class="line">@Property (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Color *color</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Shape</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)renderColor:(Color *)color &#123;</span><br><span class="line">    _color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Show %@ with %@"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>],[_color <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由上面的代码可以看出：</p>
<ul>
<li>形状类 <strong>Shape</strong> 持有 <strong>Color</strong> 类的实例，二者是以组合的形式结合到一起的。而且 <strong>Shape</strong> 类定义了供外部传入 <strong>Color</strong> 实例的方法 <code>renderColor:</code>，这个方法里面接收从外部传入的 <strong>Color</strong> 实例并保存起来；</li>
<li>另外一个公共接口 <code>show</code> 实际上就是打印这个图形的名称及其所搭配的颜色，便于我们后续验证。</li>
</ul>
</blockquote>
<p>接着我们创建三种不同的图形类，它们都继承于 <strong>Shape</strong> 类：</p>
<p>正方形类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Square.m ================== </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Square</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;   </span><br><span class="line">    [<span class="keyword">super</span> show];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>长方形类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Rectangle.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Rectangle</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;   </span><br><span class="line">    [<span class="keyword">super</span> show];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>圆形类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Circle.m ==================  </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Circle</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show&#123;   </span><br><span class="line">    [<span class="keyword">super</span> show];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>还记得上面的 <strong>Shape</strong> 类持有的 <strong>Color</strong> 类么？它就是所有颜色类的父类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Color.h ==================   </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Color</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Color.m ================== </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Color</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>接着我们创建继承这个 <strong>Color</strong> 类的三个颜色类：</p>
<p>红色类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== RedColor.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RedColor</span> : <span class="title">Color</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== RedColor.m ==================  </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RedColor</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>绿色类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== GreenColor.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GreenColor</span> : <span class="title">Color</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== GreenColor.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GreenColor</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>蓝色类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BlueColor.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BlueColor</span> : <span class="title">Color</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== BlueColor.m ==================  </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BlueColor</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>OK，到现在所有的形状类和颜色类的相关类已经创建好了，我们看一下客户端是如何使用它们来组合成不同的带有颜色的形状的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ==================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//create 3 shape instances</span></span><br><span class="line">Rectangle *rect = [[Rectangle alloc] init];</span><br><span class="line">Circle *circle = [[Circle alloc] init];</span><br><span class="line">Square *square = [[Square alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//create 3 color instances</span></span><br><span class="line">RedColor *red = [[RedColor alloc] init];</span><br><span class="line">GreenColor *green = [[GreenColor alloc] init];</span><br><span class="line">BlueColor *blue = [[BlueColor alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//rect &amp; red color</span></span><br><span class="line">[rect renderColor:red];</span><br><span class="line">[rect show];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//rect &amp; green color</span></span><br><span class="line">[rect renderColor:green];</span><br><span class="line">[rect show];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//circle &amp; blue color</span></span><br><span class="line">[circle renderColor:blue];</span><br><span class="line">[circle show];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//circle &amp; green color</span></span><br><span class="line">[circle renderColor:green];</span><br><span class="line">[circle show];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//square &amp; blue color</span></span><br><span class="line">[square renderColor:blue];</span><br><span class="line">[square show];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//square &amp; red color</span></span><br><span class="line">[square renderColor:red];</span><br><span class="line">[square show];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码里，我们先声明了所有的形状类和颜色类的实例，然后自由搭配，形成不同的形状 + 颜色的组合。</p>
</blockquote>
<p>下面我们通过打印的结果来看一下组合的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Show Rectangle with RedColor</span><br><span class="line">Show Rectangle with GreenColor</span><br><span class="line">Show Circle with BlueColor</span><br><span class="line">Show Circle with GreenColor</span><br><span class="line">Show Square with BlueColor</span><br><span class="line">Show Square with RedColor</span><br></pre></td></tr></table></figure>
<p>从打印的接口可以看出组合的结果是没问题的。</p>
<p>跟上面没有使用桥接模式的设计相比，使用桥接模式需要的类的总和是 m + n，当 m 或 n 的值很大的时候是远小于 m * n（没有使用桥接，而是使用继承的方式）的。</p>
<p>而且如果后面还要增加形状和颜色的话，使用桥接模式就可以很方便地将原有的形状和颜色和新的形状和颜色进行搭配了，新的类和旧的类互不干扰。</p>
<p>下面我们看一下上面代码所对应的类图：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190226112230.png" alt=""></p>
<blockquote>
<p>从 UML 类图可以看出，该设计是由两个抽象层的类 <strong>Shape</strong> 和 <strong>Color</strong> 构建的，正因为依赖的双方都是抽象类（而不是具体的实现），而且二者是以组合的方式联系到一起的，所以扩展起来非常方便，互不干扰。这对于今后我们对代码的设计有比较好的借鉴意义。</p>
</blockquote>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>扩展性好，符合开闭原则：将抽象与实现分离，让二者可以独立变化</p>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>在设计之前，需要识别出两个独立变化的维度。</p>
<h1 id="四、代理模式"><a href="#四、代理模式" class="headerlink" title="四、代理模式"></a>四、代理模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。</p>
</blockquote>
<p>使用代理模式以后，客户端直接访问代理，代理在客户端和目标对象之间起到中介的作用。</p>
<h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为 “代理” 的第三者来实现间接引用。</p>
<p>因为代理对象可以在客户端和目标对象之间起到中介的作用，因此可以通过代理对象去调客户不能看到的内容和服务，或者添加客户需要的额外服务。</p>
<p>根据业务的不同，代理也可以有不同的类型：</p>
<ul>
<li>远程代理：为位于不同地址或网络化中的对象提供本地代表；</li>
<li>虚拟代理：根据要求创建重型的对象；</li>
<li>保护代理：根据不同访问权限控制对原对象的访问。</li>
</ul>
<h2 id="成员与类图-3"><a href="#成员与类图-3" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>代理模式算上客户端一共有四个成员：</p>
<ul>
<li>客户端（Client）：意图访问真是主体接口；</li>
<li>抽象主题（Subejct）：抽象主题定义客户端需要访问的接口；</li>
<li>代理（Proxy）：继承于抽象主题，目的是为了它持有真实目标的实例的引用，客户端直接访问代理；</li>
<li>真实主题（RealSubject）：真实主题即是被代理的对象，它也继承于抽象主题，它的实例被代理所持有，它的接口被包装在了代理的接口中，而且客户端无法直接访问真实主题对象。</li>
</ul>
<h1 id="五、装饰者模式（Decorator）"><a href="#五、装饰者模式（Decorator）" class="headerlink" title="五、装饰者模式（Decorator）"></a>五、装饰者模式（Decorator）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。</p>
</blockquote>
<h2 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>动态地给一个对象增加职责（功能），这些职责（功能）也可以动态地被撤销；</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时。</li>
</ul>
<h2 id="成员与类图-4"><a href="#成员与类图-4" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>装饰者模式一共有四个成员：</p>
<ol>
<li>抽象构件（Component）：定义一个对象（接口），可以动态地给这些对象添加职责；</li>
<li>具体构件（Concrete Component）：是抽象构件的实例；</li>
<li>装饰者（Decorator）：继承于抽象构件，它持有一个具体构件对象的实例，并实现一个与抽象构件接口一致的接口；</li>
<li>具体装饰者（Concrete Decorator）：负责给具体构件对象实例添加上附加的责任。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190227104006.png" alt=""></p>
<h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><p>现在我们模拟沙拉的制作：沙拉由沙拉底和酱汁两个部分组成，不同的沙拉底和酱汁搭配可以组成不同的沙拉。</p>
<table>
<thead>
<tr>
<th>沙拉底</th>
<th>价格</th>
<th>酱汁</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>蔬菜</td>
<td>5</td>
<td>醋汁</td>
<td>2</td>
</tr>
<tr>
<td>鸡肉</td>
<td>10</td>
<td>花生酱</td>
<td>4</td>
</tr>
<tr>
<td>牛肉</td>
<td>16</td>
<td>蓝莓酱</td>
<td>6</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：同一份沙拉底可以搭配多种酱汁，而且酱汁的份数也可以不止一份。</p>
</blockquote>
<p>因为选择一个沙拉底之后，可以随意添加不同份数和种类的酱汁，也就是在原有的沙拉对象增加新的对象，所以比较适合用装饰者模式来设计：酱汁相当于装饰者，而沙拉底则是被装饰的构件。</p>
<p>下面我们用代码看一下如何实现该场景。</p>
<p>首先我们定义抽象构件，也就是沙拉类的基类 <strong>Salad</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Salad.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Salad</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription;</span><br><span class="line">- (<span class="keyword">double</span>)price;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getDescription</code> 和 <code>price</code> 方法用来描述当前沙拉的配置以及价格（因为随着装饰者的装饰，这两个数据会一直变化）。</p>
</blockquote>
<p>下面我们再声明装饰者的基类 <strong>SauceDecorator</strong>。按照装饰者设计模式类图，该类是继承于沙拉类的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== SauceDecorator.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SauceDecorator</span> : <span class="title">Salad</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Salad *salad;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSalad:(Salad *)salad;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== SauceDecorator.m ==================    </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SauceDecorator</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSalad:(Salad *)salad &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.salad = salad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在装饰者的构造方法里面传入 <strong>Salad</strong> 类的实例，并将它保存下来，目的是为了在装饰它的时候用到。</p>
</blockquote>
<p>现在抽象构件和装饰者的基类都创建好了，下面我们创建具体构件和具体装饰者。首先我们创建具体构件：</p>
<ul>
<li>蔬菜沙拉</li>
<li>鸡肉沙拉</li>
<li>牛肉沙拉</li>
</ul>
<p>蔬菜沙拉 <strong>VegetableSalad</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== VegetableSalad.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VegetableSalad</span> : <span class="title">Salad</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== VegetableSalad.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VegetableSalad</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"[Vegetable Salad]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先 <code>getDescription</code> 方法返回的是蔬菜沙拉底的描述，然后 <code>price</code> 方法返回的是他所对应的价格。</p>
</blockquote>
<p>类似的，我们继续按照价格表来创建鸡肉沙拉底和牛肉沙拉底：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== ChickenSalad.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChickenSalad</span> : <span class="title">Salad</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== ChickenSalad.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChickenSalad</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"[Chicken Salad]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BeefSalad.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BeefSalad</span> : <span class="title">Salad</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//================== BeefSalad.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BeefSalad</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"[Beef Salad]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">16.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>现在所有的被装饰者创建好了，下面我们按照酱汁的价格表来创建酱汁类（也就是具体装饰者）：</p>
<p>首先看一下醋汁 <strong>VinegarSauceDecorator</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== VinegarSauceDecorator.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VinegarSauceDecorator</span> : <span class="title">SauceDecorator</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== VinegarSauceDecorator.m ==================    </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VinegarSauceDecorator</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ + vinegar sauce"</span>,[<span class="keyword">self</span>.salad getDescription]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.salad price] + <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重写了 <code>getDescription</code> 方法，并添加了自己的装饰，即在原来的描述上增加了 “vinegar sauce” 字符串。之所以可以获取到原有的描述，是因为在构造方法里已经获取了被装饰者的对象（在装饰者基类中定义的方法）。同样的，价格也在原来的基础上增加了自己的价格。</p>
</blockquote>
<p>现在我们知道了具体装饰者的设计，依此类推，我们看一下花生酱和蓝莓酱类如何定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== PeanutButterSauceDecorator.h ==================     </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PeanutButterSauceDecorator</span> : <span class="title">SauceDecorator</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== PeanutButterSauceDecorator.m ==================     </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PeanutButterSauceDecorator</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ + peanut butter sauce"</span>,[<span class="keyword">self</span>.salad getDescription]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.salad price] + <span class="number">4.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BlueBerrySauceDecorator.h ==================     </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BlueBerrySauceDecorator</span> : <span class="title">SauceDecorator</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== BlueBerrySauceDecorator.m ==================     </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BlueBerrySauceDecorator</span></span></span><br><span class="line">    </span><br><span class="line">- (<span class="built_in">NSString</span> *)getDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ + blueberry sauce"</span>,[<span class="keyword">self</span>.salad getDescription]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)price &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.salad price] + <span class="number">6.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>OK，到现在所有的类已经定义好了，为了验证是否实现正确，下面用客户端尝试着搭配几种不同的沙拉吧：</p>
<ol>
<li>蔬菜加单份醋汁沙拉（7元）；</li>
<li>牛肉加双份花生酱沙拉（24元）；</li>
<li>鸡肉加单份花生酱再加单份蓝莓酱沙拉（20元）。</li>
</ol>
<p>首先我们看第一个搭配：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ==================     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vegetable salad add vinegar sauce</span></span><br><span class="line">Salad *vegetableSalad = [[VegetableSalad alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,vegetableSalad);</span><br><span class="line"></span><br><span class="line">vegetableSalad = [[VinegarSauceDecorator alloc] initWithSalad:vegetableSalad];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,vegetableSalad);</span><br></pre></td></tr></table></figure>
<p>第一次打印输出：<code>This salad is: [Vegetable Salad] and the price is: 5.00</code>，第二次打印输出：<code>This salad is: [Vegetable Salad] + vinegar sauce and the price is: 7.00</code>。</p>
<p>上面代码中，我们首先创建了蔬菜底，然后再让醋汁装饰它（将蔬菜底的实例传入酱汁装饰者的构造方法中）。最后我们打印这个蔬菜底对象，描述和价格和装饰之前的确发生了变化，说明我们的代码没有问题。</p>
<p>接着我们看第二个搭配：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ================== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//beef salad add two peanut butter sauce:</span></span><br><span class="line">Salad *beefSalad = [[BeefSalad alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,beefSalad);</span><br><span class="line"></span><br><span class="line">beefSalad = [[PeanutButterSauceDecorator alloc] initWithSalad:beefSalad];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,beefSalad);</span><br><span class="line"></span><br><span class="line">beefSalad = [[PeanutButterSauceDecorator alloc] initWithSalad:beefSalad];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,beefSalad);</span><br></pre></td></tr></table></figure>
<p>第一次打印输出：<code>[Beef Salad] and the price is: 16.00</code> 第二次打印输出：<code>[Beef Salad] + peanut butter sauce and the price is: 20.00</code>第三次打印输出：<code>[Beef Salad] + peanut butter sauce + peanut butter sauce and the price is: 24.00</code></p>
<p>和上面的代码实现类似，都是先创建沙拉底（这次是牛肉底），然后再添加调料。由于是分两次装饰，所以要再写一次花生酱的装饰代码。对比每次打印的结果和上面的价格表可以看出输出是正确的。</p>
<p>这个例子是加了两次相同的酱汁，最后我们看第三个搭配，加入的是不同的两个酱汁：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ================== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//chiken salad add peanut butter sauce and blueberry sauce</span></span><br><span class="line">Salad *chikenSalad = [[ChickenSalad alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,chikenSalad);</span><br><span class="line"></span><br><span class="line">chikenSalad = [[PeanutButterSauceDecorator alloc] initWithSalad:chikenSalad];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,chikenSalad);</span><br><span class="line"></span><br><span class="line">chikenSalad = [[BlueBerrySauceDecorator alloc] initWithSalad:chikenSalad];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,chikenSalad);</span><br></pre></td></tr></table></figure>
<p>第一次打印输出：<code>[Chicken Salad] and the price is: 10.00</code>第二次打印输出：<code>[Chicken Salad] + peanut butter sauce and the price is: 14.00</code>第三次打印输出：<code>[Chicken Salad] + peanut butter sauce + blueberry sauce and the price is: 20.00</code>。</p>
<p>对比每次打印的结果和上面的价格表可以看出输出是正确的。</p>
<p>到这里，该场景就模拟结束了。可以试想一下，如果今后加了其它的沙拉底和酱汁的话，只需要分别继承 <strong>Salad</strong> 类和 <strong>SauceDecorator</strong> 类就可以了，现有的代码并不需要更改，而且经过不同组合可以搭配出更多种类的沙拉。</p>
<p>下面我们看一下该代码实现对应的类图：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190227134011.png" alt=""></p>
<h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><ul>
<li>比继承更加灵活：不同于在编译期起作用的继承；装饰者模式可以在运行时扩展一个对象的功能。另外也可以通过配置文件在运行时选择不同的装饰器，从而实现不同的行为。也可以通过不同的组合，可以实现不同效果。</li>
<li>符合“开闭原则”：装饰者和被装饰者可以独立变化。用户可以根据需要增加新的装饰类，在使用时再对其进行组合，原有代码无须改变。</li>
</ul>
<h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>装饰者模式需要创建一些具体装饰类，会增加系统的复杂度。</p>
<h1 id="六、享元模式（Flyweight）"><a href="#六、享元模式（Flyweight）" class="headerlink" title="六、享元模式（Flyweight）"></a>六、享元模式（Flyweight）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>运用共享技术复用大量细粒度的对象，降低程序内存的占用，提高程序的性能。</p>
</blockquote>
<p>定义解读：</p>
<ul>
<li>享元模式的目的就是使用共享技术来实现大量细粒度对象的复用，提高性能；</li>
<li>享元对象能做到共享的关键是区分内部状态（Internal State）和外部状态（External State）。<ul>
<li><strong>内部状态</strong>是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；</li>
<li><strong>外部状态</strong>是随环境改变而改变的，不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</li>
</ul>
</li>
</ul>
<p>享元模式其实就是指一套缓存系统。显然它是一种复合模式，使用工厂模式来创造实例。适用场景是系统中存在重复的对象创建过程。好处是节省了内存加快了速度。</p>
<h2 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>系统有大量的相似对象，这些对象有一些外在状态；</li>
<li>应当在多次重复使用享元对象时才值得使用享元模式。使用享元模式需要维护一个存储享元对象的享元池，而这需要消耗资源，</li>
</ul>
<h2 id="成员与类图-5"><a href="#成员与类图-5" class="headerlink" title="成员与类图"></a>成员与类图</h2><p>享元模式一共有三个成员：</p>
<ul>
<li>享元工厂（FlyweightFactory）：提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象；</li>
<li>抽象享元（Flyweight）：定义了具体享元对象需要实现的接口；</li>
<li>具体享元（ConcreteFlyweight）：实现了抽象享元类定义的接口。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190227150844.png" alt=""></p>
<h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><p>这里我们使用<a href="https://link.juejin.im/?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F6920082%2F" target="_blank" rel="noopener">《Objective-C 编程之道：iOS设计模式解析》</a>里的第21章使用的例子：在一个页面展示数百个大小，位置不同的花的图片，然而这些花的样式只有6种。</p>
<p>看一下截图：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190227151007.png" alt=""></p>
<p>由于这里我们需要创建很多对象，而这些对象有可以共享的内部状态（6张图片内容）以及不同的外部状态（随机的，数百个位置坐标和图片大小），因此比较适合使用享元模式来做。</p>
<p>根据上面提到的享元模式的成员：</p>
<ul>
<li>我们需要创建一个工厂类来根据花的类型来返回花对象（这个对象包括内部可以共享的图片以及外部状态位置和大小）：每次当新生成一种花的类型的对象的时候就把它保存起来，因为下次如果还需要这个类型的花内部图片对象的时候就可以直接用了；</li>
<li>抽象享元类就是 Objective-C 的原生 <strong>UIImageView</strong>，它可以显示图片；</li>
<li>具体享元类可以自己定义一个类继承于 <strong>UIImageView</strong>，因为后续我们可以直接添加更多其他的属性。</li>
</ul>
<p>下面我们看一下用代码如何实现：</p>
<p>首先我们创建一个工厂，这个工厂可以根据所传入花的类型来返回花内部图片对象，在这里可以直接使用原生的 <strong>UIImage</strong> 对象，也就是图片对象。而且这个工厂持有一个保存图片对象的池子：</p>
<ul>
<li>当该类型的花第一次被创建时，工厂会新建一个所对应的花内部图片对象，并将这个对象放入池子中保存起来；</li>
<li>当该类型的花内部图片对象在池子里已经有了，那么工厂则直接从池子里返回这个花内部图片对象。</li>
</ul>
<p>下面我们看一下这个工厂类的代码实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== FlowerFactory.h ================== </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, FlowerType) &#123;</span><br><span class="line">    FlowerTypeAnemone,</span><br><span class="line">    FlowerTypeCosmos,</span><br><span class="line">    FlowerTypeGerberas,</span><br><span class="line">    FlowerTypeHollyhock,</span><br><span class="line">    FlowerTypeJasmine,</span><br><span class="line">    FlowerTypeZinnia,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FlowerFactory</span> : <span class="title">NSObject</span> </span></span><br><span class="line"></span><br><span class="line">- (FlowerImageView *)flowerImageWithType:(FlowerType)type</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== FlowerFactory.m ================== </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FlowerFactory</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_flowersPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _flowersPool = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">6</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (FlowerImageView *)flowerImageWithType:(FlowerType)type &#123;  </span><br><span class="line">    <span class="comment">// 尝试获取传入类型对应的花内部图片对象</span></span><br><span class="line">    <span class="built_in">UIImage</span> *flowerImage = _flowersPool[@(type)];</span><br><span class="line">    <span class="comment">// 如果没有对应类型的图片，则生成一个</span></span><br><span class="line">    <span class="keyword">if</span> (!flowerImage)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"create new flower image with type:%u"</span>,type);</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;   </span><br><span class="line">            <span class="keyword">case</span> kAnemone:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"anemone.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCosmos:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"cosmos.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kGerberas:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gerberas.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kHollyhock:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"hollyhock.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kJasmine:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"jasmine.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kZinnia:</span><br><span class="line">                flowerImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"zinnia.png"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        _flowersPool[@(type)] = flowerImage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有对应类型的图片，则直接使用</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"reuse flower image with type:%u"</span>,type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建花对象，将上面拿到的花内部图片对象赋值并返回</span></span><br><span class="line">    FlowerImageView *flowerImageView = [[FlowerImageView alloc] initWithImage:flowerImage];</span><br><span class="line">    <span class="keyword">return</span> flowerImageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>在这个工厂类里面定义了六种图片的类型；</li>
<li>该工厂类持有 <code>_flowersPool</code> 私有成员变量，保存新创建过的图片；</li>
<li><code>flowerImageWithType:</code> 的实现，结合了 <code>_flowersPool</code>，当 <code>_flowersPool</code> 没有对应的图片时，新创建图片并返回，否则直接从 <code>_flowersPool</code> 获取对应的图片并返回。</li>
</ul>
</blockquote>
<p>接着我们定义这些花对象 <strong>FlowerImageView</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== FlowerImageView.h ================== </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FlowerImageView</span> : <span class="title">UIImageView</span> </span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== FlowerImageView.m ================== </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FlowerImageView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里其实也可以直接使用 <strong>UIImageView</strong>，之所以创建一个子类是为了后面可以更好地扩展这些花独有的一些属性。</p>
<p>注意一下花对象和花内部图片对象的区别：花对象 <strong>FlowerImageView</strong> 是包含花内部图片对象的 <strong>UIImage</strong>。因为在 Objective-C 里面，<strong>UIImage</strong> 是 <strong>FlowerImageView</strong> 所继承的 <strong>UIImageView</strong> 的一个属性，所以在这里 <strong>FlowerImageView</strong> 就直接包含了 <strong>UIImage</strong>。</p>
</blockquote>
<p>下面我们来看一下客户端如何使用 <strong>FlowerFactory</strong> 和 <strong>FlowerImageView</strong> 这两个类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== client ================== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先建造一个生产花内部图片对象的工厂</span></span><br><span class="line">FlowerFactory *factory = [[FlowerFactory alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 随机传入一个花的类型，让工厂返回该类型对应花类型的花对象</span></span><br><span class="line">    FlowerType flowerType = arc4random() % kTotalNumberOfFlowerTypes;</span><br><span class="line">    FlowerImageView *flowerImageView = [factory flowerImageWithType:flowerType];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建花对象的外部属性值（随机的位置和大小）</span></span><br><span class="line">    <span class="built_in">CGRect</span> screenBounds = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</span><br><span class="line">    <span class="built_in">CGFloat</span> x = (arc4random() % (<span class="built_in">NSInteger</span>)screenBounds.size.width);</span><br><span class="line">    <span class="built_in">CGFloat</span> y = (arc4random() % (<span class="built_in">NSInteger</span>)screenBounds.size.height);</span><br><span class="line">    <span class="built_in">NSInteger</span> minSize = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> maxSize = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> size = (arc4random() % (maxSize - minSize + <span class="number">1</span>)) + minSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将位置和大小赋予花对象</span></span><br><span class="line">    flowerImageView.frame = <span class="built_in">CGRectMake</span>(x, y, size, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示这个花对象</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:flowerImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码里面是生成了 500 朵位置和大小都是随机的花内部图片对象。这500朵花最主要的区别还是它们的位置和大小。而它们使用的花的图片对象只有6个，因此可以用专门的 <strong>Factory</strong> 来生成和管理这些少数的花内部图片对象，从工厂的打印我们可以看出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create new flower image with type:<span class="number">1</span></span><br><span class="line">create new flower image with type:<span class="number">3</span></span><br><span class="line">create new flower image with type:<span class="number">4</span></span><br><span class="line">reuse flower image with type:<span class="number">3</span></span><br><span class="line">create new flower image with type:<span class="number">5</span></span><br><span class="line">create new flower image with type:<span class="number">2</span></span><br><span class="line">create new flower image with type:<span class="number">0</span></span><br><span class="line">reuse flower image with type:<span class="number">5</span></span><br><span class="line">reuse flower image with type:<span class="number">5</span></span><br><span class="line">reuse flower image with type:<span class="number">4</span></span><br><span class="line">reuse flower image with type:<span class="number">1</span></span><br><span class="line">reuse flower image with type:<span class="number">3</span></span><br><span class="line">reuse flower image with type:<span class="number">4</span></span><br><span class="line">reuse flower image with type:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从上面的打印结果可以看出，在六种图片都创建好以后，再获取时就直接拿生成过的图片了，在一定程度上减少了内存的开销。</p>
<p>下面我们看一下该代码示例对应的 UML 类图：</p>
<p><img src="https://raw.githubusercontent.com/zhongbisheng/blog_image/master/20190227154426.png" alt=""></p>
<blockquote>
<p>这里需要注意的是：</p>
<ul>
<li>工厂和花对象是组合关系：<strong>FlowerFactroy</strong> 生成了多个 <strong>FlowerImageView</strong> 对象，也就是花的内部图片对象，二者的关系属于强关系，因为在该例子中二者如果分离而独立存在都将会失去意义，所以在UML类图中用了组合的关系（实心菱形）；</li>
<li>抽象享元类是 <strong>UIImageView</strong>，它的一个内部对象是 <strong>UIImage</strong>（这两个都是Objective-C原生的关于图片的类）；</li>
<li>客户端依赖的对象是工厂对象和花对象，而对花的内部图片对象 <strong>UIImage</strong> 可以一无所知，因为它是被 <strong>FlowerFactroy</strong> 创建并被 <strong>FlowerImageView</strong> 所持有的。（但是因为 <strong>UIImage</strong> 是 <strong>FlowerImageView</strong> 的一个外部可以引用的属性，所以在这里客户端还是可以访问到 <strong>UIImage</strong>，这是 Objective-C 原生的实现。后面我们在用享元模式的时候可以不将内部属性暴露出来）。</li>
</ul>
</blockquote>
<h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><ul>
<li>使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
<h2 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li>
<li>对象在缓冲池中的复用需要考虑线程问题。</li>
</ul>
<h2 id="Objective-C-的实践-1"><a href="#Objective-C-的实践-1" class="headerlink" title="Objective-C 的实践"></a>Objective-C 的实践</h2><p>iOS SDK中的 <strong>UITableViewCell</strong> 的复用池就是使用享元模式的一个例子。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#设计模式">
    <span class="tag-code">设计模式</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/09/16/面向对象设计模式（二）：创建型设计模式/">
        <span class="nav-arrow">← </span>
        
          面向对象设计模式（二）：创建型设计模式
        
      </a>
    
    
      <a class="nav-right" href="/2018/09/20/面向对象设计模式（四）：行为型设计模式/">
        
          面向对象设计模式（四）：行为型设计模式
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#一、外观模式（Facade）"><span class="toc-nav-text">一、外观模式（Facade）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场景"><span class="toc-nav-text">适用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图"><span class="toc-nav-text">成员与类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代码示例"><span class="toc-nav-text">代码示例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优点"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺点"><span class="toc-nav-text">缺点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Objective-C-的实践"><span class="toc-nav-text">Objective-C 的实践</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#二、适配器模式（Adapter）"><span class="toc-nav-text">二、适配器模式（Adapter）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义-1"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场景-1"><span class="toc-nav-text">适用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图-1"><span class="toc-nav-text">成员与类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代码示例-1"><span class="toc-nav-text">代码示例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优点-1"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺点-1"><span class="toc-nav-text">缺点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#三、桥接模式"><span class="toc-nav-text">三、桥接模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义-2"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场合"><span class="toc-nav-text">适用场合</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图-2"><span class="toc-nav-text">成员与类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代码示例-2"><span class="toc-nav-text">代码示例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优点-2"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺点-2"><span class="toc-nav-text">缺点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#四、代理模式"><span class="toc-nav-text">四、代理模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义-3"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场景-2"><span class="toc-nav-text">适用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图-3"><span class="toc-nav-text">成员与类图</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#五、装饰者模式（Decorator）"><span class="toc-nav-text">五、装饰者模式（Decorator）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义-4"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场景-3"><span class="toc-nav-text">适用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图-4"><span class="toc-nav-text">成员与类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代码示例-3"><span class="toc-nav-text">代码示例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优点-3"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺点-3"><span class="toc-nav-text">缺点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#六、享元模式（Flyweight）"><span class="toc-nav-text">六、享元模式（Flyweight）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#定义-5"><span class="toc-nav-text">定义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#适用场景-4"><span class="toc-nav-text">适用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#成员与类图-5"><span class="toc-nav-text">成员与类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代码示例-4"><span class="toc-nav-text">代码示例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优点-4"><span class="toc-nav-text">优点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缺点-4"><span class="toc-nav-text">缺点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Objective-C-的实践-1"><span class="toc-nav-text">Objective-C 的实践</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/09/18/面向对象设计模式（三）：结构型设计模式/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "面向对象设计模式（三）：结构型设计模式",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2018/09/18/面向对象设计模式（三）：结构型设计模式/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>